# [객체지향 프로그래밍 Part5](#예시)

## Atom70 객체

- `object`의 정의
 - 여러 개의 객체(인스턴스)가 필요하지 않거나 명시적으로 인스턴스를 여러 개 생성하는 것을 막고 싶은 경우 `object` 키워드를 통해서 클래스처럼 선언하면 이것은 싱글톤 패턴을 가진 객체가 된다. 즉 인스턴스가 1개만 존재하는 객체를 말하는 것! 

- `object` 키워드의 특징
  1. 내부적으로 객체 구조를 정의하는 동시에 객체를 생성하기때문에 추가적인 인스턴스 생성할 수 없다. 
  2. 클래스와 유사하게, object 라고 정의한 객체의 내부 공간에 내부 원소들(프로퍼티와 멤버함수)을 정의한다.
  3. object 앞에 private를 사용하면 object를 정의한 파일 안에서만 접근이 가능하다.
  4. object 내부에서의 this는 유일한 객체 인스턴스를 가르킨다.
  5. object는 다른 클래스와 인터페이스를 상속받을 수 있다. 


```kotlin
object JustOne { // 2️⃣
  val n = 2
  fun f() = n * 10
  fun g() = this.n * 20   // 4️⃣
}

fun main() {
  // val x = JustOne() // Error // 1️⃣
  JustOne.n eq 2
  JustOne.f() eq 20
  JustOne.g() eq 40
}
```
```kotlin
private object JustOne {
  val n = 2
  fun f() = n * 10
  fun g() = this.n * 20   // [1]
}

```

```kotlin
open class Paint(val color: String) {
  open fun apply() = "Applying $color"
}

object Acrylic: Paint("Blue") { // 5️⃣
  override fun apply() =
    "Acrylic, ${super.apply()}"
}

interface PaintPreparation {
  fun prepare(): String
}

object Prepare: PaintPreparation { // 5️⃣
  override fun prepare() = "Scrape"
}

fun main() {
  Prepare.prepare() eq "Scrape"
  Paint("Green").apply() eq "Applying Green"
  Acrylic.apply() eq "Acrylic, Applying Blue"
}
```

6. object의 인스턴스를 단 1개이므로 object를 사용하는 모든 코드에서 같은 인스턴스 객체가 공유된다.

```kotlin
object Shared {
  var i: Int = 0
}

//private object Shared {
//  var i: Int = 0
//}
```
> 위에서 선언된 `Shared` 객체를 아래 코드들에서 공유하여 사용한다. 만약에 private 으로 정의되었다면 다른 코드에서 공유가 불가능하다.
> `Cannot access 'Shared': it is private in file` 에러 발생

```kotlin
package objectshare1

import objectsharing.Shared

fun f() {
  Shared.i += 5
}
```

```kotlin
package objectshare2

import objectsharing.Shared
import objectshare1.f
import atomictest.eq

fun g() {
  Shared.i += 7
}  

fun main() {
  f()
  g()
  Shared.i eq 12
}
```


7. object 안에 object, 클래스 안에 object는 가능하다. 하지만 함수 안에 object는 불가능하다.

```kotlin
object Outer {
  object Nested {
    val a = "Outer.Nested.a"
  }
}

class HasObject {
  object Nested {
    val a = "HasObject.Nested.a"
  }
}
// 클래스 안에 객체를 넣는 방법 : companion object (Atom72)

fun main() {
  Outer.Nested.a eq "Outer.Nested.a"
  HasObject.Nested.a eq "HasObject.Nested.a"
}

```

```kotlin
fun fn() {
  object NestedObject{ 

  }
}
```
> `Named object 'NestedObject' is a singleton and cannot be local. Try to use anonymous object instead` 오류 발생 → object는 싱글톤으로 전역적인 객체를 생성하는데, 함수 내부의 object는 로컬 스코프를 갖게됨으로 개념상 맞지 않기때문에 오류를 발생한다. 오류에서 볼수 있듯이 익명 객체를 생성하면 에러가 사라진다.

### 참고1 : 익명 객체
```kotlin
fun main() {
    val anonymous = object {
        val message = "Hello from anonymous"
    }
    println(anonymous.message) // "Hello from anonymous"
}
```
- 이름 없이 생성되는 객체로서 object 키워드로 일회성의 객체를 만들 때 사용
- 로컬 스코프에서만 사용
- 싱글톤 패턴이 아니라 함수가 호출될 때마다 다른 객체가 생성된다. 
- 사용처 : 객체를 전달하거나 인라인 함수 내에서 임시 객체를 사용해야 할 때 유용

## Atom71 내부 클래스


## Atom72 동반 객체


# 실패 방지하기

## Atom73 예외 처리

## Atom74 검사 명령