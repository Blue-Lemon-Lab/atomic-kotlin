# ê°ì²´ì§€í–¥ í”„ë¡œê·¸ë˜ë° Part5

## Atom70 ê°ì²´

- `object`ì˜ ì •ì˜
 - ì—¬ëŸ¬ ê°œì˜ ê°ì²´(ì¸ìŠ¤í„´ìŠ¤)ê°€ í•„ìš”í•˜ì§€ ì•Šê±°ë‚˜ ëª…ì‹œì ìœ¼ë¡œ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ì—¬ëŸ¬ ê°œ ìƒì„±í•˜ëŠ” ê²ƒì„ ë§‰ê³  ì‹¶ì€ ê²½ìš° `object` í‚¤ì›Œë“œë¥¼ í†µí•´ì„œ í´ë˜ìŠ¤ì²˜ëŸ¼ ì„ ì–¸í•˜ë©´ ì´ê²ƒì€ ì‹±ê¸€í†¤ íŒ¨í„´ì„ ê°€ì§„ ê°ì²´ê°€ ëœë‹¤. ì¦‰ ì¸ìŠ¤í„´ìŠ¤ê°€ 1ê°œë§Œ ì¡´ì¬í•˜ëŠ” ê°ì²´ë¥¼ ë§í•˜ëŠ” ê²ƒ! 

- `object` í‚¤ì›Œë“œì˜ íŠ¹ì§•
  1. ë‚´ë¶€ì ìœ¼ë¡œ ê°ì²´ êµ¬ì¡°ë¥¼ ì •ì˜í•˜ëŠ” ë™ì‹œì— ê°ì²´ë¥¼ ìƒì„±í•˜ê¸°ë•Œë¬¸ì— ì¶”ê°€ì ì¸ ì¸ìŠ¤í„´ìŠ¤ ìƒì„±í•  ìˆ˜ ì—†ë‹¤. 
  2. í´ë˜ìŠ¤ì™€ ìœ ì‚¬í•˜ê²Œ, object ë¼ê³  ì •ì˜í•œ ê°ì²´ì˜ ë‚´ë¶€ ê³µê°„ì— ë‚´ë¶€ ì›ì†Œë“¤(í”„ë¡œí¼í‹°ì™€ ë©¤ë²„í•¨ìˆ˜)ì„ ì •ì˜í•œë‹¤.
  3. object ì•ì— privateë¥¼ ì‚¬ìš©í•˜ë©´ objectë¥¼ ì •ì˜í•œ íŒŒì¼ ì•ˆì—ì„œë§Œ ì ‘ê·¼ì´ ê°€ëŠ¥í•˜ë‹¤.
  4. object ë‚´ë¶€ì—ì„œì˜ thisëŠ” ìœ ì¼í•œ ê°ì²´ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ê°€ë¥´í‚¨ë‹¤.
  5. objectëŠ” ë‹¤ë¥¸ í´ë˜ìŠ¤ì™€ ì¸í„°í˜ì´ìŠ¤ë¥¼ ìƒì†ë°›ì„ ìˆ˜ ìˆë‹¤. 


```kotlin
object JustOne { // 2ï¸âƒ£
  val n = 2
  fun f() = n * 10
  fun g() = this.n * 20   // 4ï¸âƒ£
}

fun main() {
  // val x = JustOne() // Error // 1ï¸âƒ£
  JustOne.n eq 2
  JustOne.f() eq 20
  JustOne.g() eq 40
}
```
```kotlin
private object JustOne {
  val n = 2
  fun f() = n * 10
  fun g() = this.n * 20   // [1]
}

```

```kotlin
open class Paint(val color: String) {
  open fun apply() = "Applying $color"
}

object Acrylic: Paint("Blue") { // 5ï¸âƒ£
  override fun apply() =
    "Acrylic, ${super.apply()}"
}

interface PaintPreparation {
  fun prepare(): String
}

object Prepare: PaintPreparation { // 5ï¸âƒ£
  override fun prepare() = "Scrape"
}

fun main() {
  Prepare.prepare() eq "Scrape"
  Paint("Green").apply() eq "Applying Green"
  Acrylic.apply() eq "Acrylic, Applying Blue"
}
```

6. objectì˜ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ë‹¨ 1ê°œì´ë¯€ë¡œ objectë¥¼ ì‚¬ìš©í•˜ëŠ” ëª¨ë“  ì½”ë“œì—ì„œ ê°™ì€ ì¸ìŠ¤í„´ìŠ¤ ê°ì²´ê°€ ê³µìœ ëœë‹¤.

```kotlin
object Shared {
  var i: Int = 0
}

//private object Shared {
//  var i: Int = 0
//}
```
> ìœ„ì—ì„œ ì„ ì–¸ëœ `Shared` ê°ì²´ë¥¼ ì•„ë˜ ì½”ë“œë“¤ì—ì„œ ê³µìœ í•˜ì—¬ ì‚¬ìš©í•œë‹¤. ë§Œì•½ì— private ìœ¼ë¡œ ì •ì˜ë˜ì—ˆë‹¤ë©´ ë‹¤ë¥¸ ì½”ë“œì—ì„œ ê³µìœ ê°€ ë¶ˆê°€ëŠ¥í•˜ë‹¤.
> `Cannot access 'Shared': it is private in file` ì—ëŸ¬ ë°œìƒ

```kotlin
package objectshare1

import objectsharing.Shared

fun f() {
  Shared.i += 5
}
```

```kotlin
package objectshare2

import objectsharing.Shared
import objectshare1.f
import atomictest.eq

fun g() {
  Shared.i += 7
}  

fun main() {
  f()
  g()
  Shared.i eq 12
}
```


7. object ì•ˆì— object, í´ë˜ìŠ¤ ì•ˆì— objectëŠ” ê°€ëŠ¥í•˜ë‹¤. í•˜ì§€ë§Œ í•¨ìˆ˜ ì•ˆì— objectëŠ” ë¶ˆê°€ëŠ¥í•˜ë‹¤.

```kotlin
object Outer {
  object Nested {
    val a = "Outer.Nested.a"
  }
}

class HasObject {
  object Nested {
    val a = "HasObject.Nested.a"
  }
}
// í´ë˜ìŠ¤ ì•ˆì— ê°ì²´ë¥¼ ë„£ëŠ” ë°©ë²• : companion object (Atom72)

fun main() {
  Outer.Nested.a eq "Outer.Nested.a"
  HasObject.Nested.a eq "HasObject.Nested.a"
}

```

```kotlin
fun fn() {
  object NestedObject{ 

  }
}
```
> `Named object 'NestedObject' is a singleton and cannot be local. Try to use anonymous object instead` ì˜¤ë¥˜ ë°œìƒ â†’ objectëŠ” ì‹±ê¸€í†¤ìœ¼ë¡œ ì „ì—­ì ì¸ ê°ì²´ë¥¼ ìƒì„±í•˜ëŠ”ë°, í•¨ìˆ˜ ë‚´ë¶€ì˜ objectëŠ” ë¡œì»¬ ìŠ¤ì½”í”„ë¥¼ ê°–ê²Œë¨ìœ¼ë¡œ ê°œë…ìƒ ë§ì§€ ì•Šê¸°ë•Œë¬¸ì— ì˜¤ë¥˜ë¥¼ ë°œìƒí•œë‹¤. ì˜¤ë¥˜ì—ì„œ ë³¼ìˆ˜ ìˆë“¯ì´ ìµëª… ê°ì²´ë¥¼ ìƒì„±í•˜ë©´ ì—ëŸ¬ê°€ ì‚¬ë¼ì§„ë‹¤.

### ì°¸ê³ 1 : ìµëª… ê°ì²´
```kotlin
fun main() {
    val anonymous = object {
        val message = "Hello from anonymous"
    }
    println(anonymous.message) // "Hello from anonymous"
}
```
- ì´ë¦„ ì—†ì´ ìƒì„±ë˜ëŠ” ê°ì²´ë¡œì„œ object í‚¤ì›Œë“œë¡œ ì¼íšŒì„±ì˜ ê°ì²´ë¥¼ ë§Œë“¤ ë•Œ ì‚¬ìš©
- ë¡œì»¬ ìŠ¤ì½”í”„ì—ì„œë§Œ ì‚¬ìš©
- ì‹±ê¸€í†¤ íŒ¨í„´ì´ ì•„ë‹ˆë¼ í•¨ìˆ˜ê°€ í˜¸ì¶œë  ë•Œë§ˆë‹¤ ë‹¤ë¥¸ ê°ì²´ê°€ ìƒì„±ëœë‹¤. 
- ì‚¬ìš©ì²˜ : ê°ì²´ë¥¼ ì „ë‹¬í•˜ê±°ë‚˜ ì¸ë¼ì¸ í•¨ìˆ˜ ë‚´ì—ì„œ ì„ì‹œ ê°ì²´ë¥¼ ì‚¬ìš©í•´ì•¼ í•  ë•Œ ìœ ìš©

## Atom71 ë‚´ë¶€ í´ë˜ìŠ¤(inner class)
- inner class 
 - ìì‹ ì„ ë‘˜ëŸ¬ì‹¼ í´ë˜ìŠ¤ì˜ ê°ì²´ì— ëŒ€í•œ ì•”ì‹œì ì¸ ë§í¬ë¥¼ ê°€ì§€ê³  ìˆëŠ” í´ë˜ìŠ¤
 - inner classëŠ” outer classì˜ ë©¤ë²„ì— ì ‘ê·¼ì´ ê°€ëŠ¥í•˜ë‹¤.(ì°¸ì¡°ê°€ ê°€ëŠ¥í•˜ë‹¤)
   - vs nested class(ì¤‘ì²© í´ë˜ìŠ¤) ëŠ” outer classì˜ ë©¤ë²„ì— ì ‘ê·¼ì´ ë¶ˆê°€ëŠ¥í•˜ë‹¤. ë‹¨, ìƒì„±ìì—ëŠ” ì ‘ê·¼ì´ ê°€ëŠ¥í•˜ì—¬ nested class ë‚´ë¶€ì—ì„œ outer classë¥¼ ìƒì„±í•´ì„œ ì ‘ê·¼ì€ ê°€ëŠ¥í•˜ì˜€ë‹¤.
 - ë°˜ëŒ€ë¡œ outer classëŠ” inner classì˜ ë©¤ë²„ì— ëŒ€í•œ ì ‘ê·¼ì´ ë¶ˆê°€ëŠ¥í•˜ë‹¤. outer class ì—ì„œ inner classë¥¼ ì‚¬ìš©í•˜ê¸°ìœ„í•´ì„  inner classì˜ ê°ì²´ë¥¼ ìƒì„±í•˜ì—¬ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.

```kotlin
class Hotel(private val reception: String) {
  open inner class Room(val id: Int = 0) {
    fun callReception() =
      "Room $id Calling $reception" // outer classì˜ receptionì— ì ‘ê·¼ ê°€ëŠ¥
  }
  
  private inner class Closet : Room() // inner classë¥¼ ìƒì†ë°›ëŠ” í´ë˜ìŠ¤ ì—­ì‹œ inner class ì—¬ì•¼í•œë‹¤. ğŸ’¡
  fun closet(): Room = Closet()

  /* ì°¸ê³  */
  //  class Nested : Room() { // ì—ëŸ¬ ë°œìƒ : Unresolved reference: Room
  //    val name = "nested"
  //  }
}

fun main() {
  val nycHotel = Hotel("311")
  val room = nycHotel.Room(319) // inner classë¥¼ ì‚¬ìš©í•˜ë ¤ë©´ ë¨¼ì € outer classì˜ ê°ì²´ë¥¼ ìƒì„±í•´ì•¼í•œë‹¤.
  room.callReception() eq
    "Room 319 Calling 311"
  val sfHotel = Hotel("0")
  val closet = sfHotel.closet()
  closet.callReception() eq "Room 0 Calling 0"
}

```

> `inner classë¥¼ ìƒì†ë°›ëŠ” í´ë˜ìŠ¤ ì—­ì‹œ inner class` : inner classê°€ outer classì— ëŒ€í•œ ì°¸ì¡°ë¥¼ ê°€ì§€ê³  ìˆê¸°ë•Œë¬¸ì— ì ‘ê·¼ì´ ê°€ëŠ¥í•œë°, ì´ë¥¼ ìƒì†ë°›ì€ í´ë˜ìŠ¤ê°€ inner classê°€ ì•„ë‹ˆë¼ë©´ ë¶€ëª¨ í´ë˜ìŠ¤ëŠ” outer classì™€ ì—°ê²°ë˜ëŠ”ë°, ìì‹ í´ë˜ìŠ¤ëŠ” outer classì™€ ì—°ê²°ì´ ì•ˆëœë‹¤ëŠ” ë…¼ë¦¬ê°€ ë˜ê¸°ë•Œë¬¸ì—, ìì‹ í´ë˜ìŠ¤ë„ inner classì—¬ì•¼í•œë‹¤. 

<br />

- í•œì •ëœ this
  - ì¼ë°˜ì ìœ¼ë¡œ ì½”í‹€ë¦°ì—ì„œ thisëŠ” í˜„ì¬ ê°ì²´ë¥¼ ê°€ë¥´í‚¤ê¸°ë•Œë¬¸ì— ìƒëµ
  - ì—¬ëŸ¬ ê°œì˜ inner classê°€ ìˆëŠ” ê²½ìš° thisê°€ ë¶ˆë¶„ëª…í•˜ì—¬ `this@[í´ë˜ìŠ¤ì´ë¦„].[ì ‘ê·¼ë©¤ë²„ì´ë¦„]` í˜•ì‹ìœ¼ë¡œ ë¶„ëª…í•˜ê²Œ í‘œí˜„í•œë‹¤. â†’ **í•œì •ëœ this êµ¬ë¬¸**
  - ì—¬ëŸ¬ ê°œì˜ í´ë˜ìŠ¤ê°€ ì¤‘ì²©ëœ ê²½ìš°, ê·¸ëƒ¥ thisë¼ê³  ì ëŠ” ê²½ìš°ëŠ” í˜„ì¬ ìœ„ì¹˜í•œ í´ë˜ìŠ¤ì—ì„œ ì ‘ê·¼í•˜ë ¤ëŠ” ë©¤ë²„ë¥¼ ì°¾ëŠ”ë‹¤.(ì—†ìœ¼ë©´ ì—ëŸ¬ ë°œìƒ) 
- ì•„ë˜ ì½”ë“œ êµ¬ì¡°ì  ë¶„ì„
  - Outer Class : Fruit â†’ ì•”ì‹œì ì¸ ë ˆì´ë¸” `this@Fruit`
    - Inner Class : Seed â†’ ì•”ì‹œì ì¸ ë ˆì´ë¸” `this@Seed`
      - Inner Class : DNA â†’ ì•”ì‹œì ì¸ ë ˆì´ë¸” `this@DNA`
  - Fruit í™•ì¥í•¨ìˆ˜ 
  - Fruit.Seed í™•ì¥í•¨ìˆ˜
  - Fruit.Seed.DNA í™•ì¥í•¨ìˆ˜

```kotlin
import typechecking.name // í•´ë‹¹ ê°ì²´ì˜ í´ë˜ìŠ¤ ì´ë¦„ì„ ê°„í¸í•˜ê²Œ ê°€ì ¸ì˜¬ ìˆ˜ ìˆë„ë¡ í•˜ëŠ” ì—­í• ì„ í•˜ëŠ” í™•ì¥ í”„ë¡œí¼í‹°. (ìì²´ì ìœ¼ë¡œ ë§Œë“ ê²ƒì¸ë“¯..)

class Fruit { 
  fun changeColor(color: String) =
    "Fruit $color"
  fun absorbWater(amount: Int) {}
  
  inner class Seed { 
    fun changeColor(color: String) =
      "Seed $color"
    fun germinate() {}
    fun whichThis() {
      this.name eq "Seed" // this.nameì€ í˜„ì¬ í´ë˜ìŠ¤ì˜ ì´ë¦„ì„ ê°€ì ¸ì˜¨ë‹¤
      this@Seed.name  eq "Seed" // ë¶„ëª…í•˜ê²Œ í•˜ê¸° ìœ„í•´ì„œ ë ˆì´ë¸”ì„ ì‚¬ìš©
      this@Fruit.name  eq "Fruit" // outer classì˜ ì´ë¦„ì„ ê°€ì ¸ì˜¨ë‹¤.
      // this@DNA.name  // ìì‹ ì˜ inner classì—ëŠ” ì ‘ê·¼í•  ìˆ˜ ì—†ë‹¤. (Seed-DNAëŠ” outer classì™€ inner classì˜ ê´€ê³„ê°€ ë¨)
    }
    
    inner class DNA {
      fun changeColor(color: String) {
        // changeColor(color) // ì¬ê·€í˜¸ì¶œ
        this@Seed.changeColor(color)
        this@Fruit.changeColor(color)
      }
      fun plant() { 
          // outer classì˜ ë©¤ë²„ì— ì ‘ê·¼ ê°€ëŠ¥
        germinate()  // Seed
        absorbWater(10) // Fruit
      }
      
      fun Int.grow() { // ì•”ì‹œì ìœ¼ë¡œ @grow ë ˆì´ë¸”ì´ ë¶™ëŠ”ë‹¤
        this.name eq "Int" // ê¸°ë³¸ì ìœ¼ë¡œ thisëŠ” ìˆ˜ì‹ ê°ì²´ì¸ Int ë¥¼ ê°€ë¥´í‚´
        this@grow.name  eq "Int" // ê¸°ë³¸ê°’ê³¼ ë™ì¼
        
        // ì—¬ê¸°ì„œë„ ëª¨ë“  outer classì˜ ë©¤ë²„ì— ì ‘ê·¼ ê°€ëŠ¥
        this@DNA.name  eq "DNA"
        this@Seed.name  eq "Seed"
        this@Fruit.name  eq "Fruit"
      }
      
      // ì™¸ë¶€ í´ë˜ìŠ¤ì— ëŒ€í•œ í™•ì¥í•¨ìˆ˜ë“¤
      fun Seed.plant() {}
      fun Fruit.plant() {}
      fun whichThis() {
        this.name eq "DNA" // ê¸°ë³¸ê°’ì€ í™•ì¥í•¨ìˆ˜ê°€ ì†í•œ í˜„ì¬ í´ë˜ìŠ¤
        this@DNA.name  eq "DNA"
        // ì—¬ê¸°ì„œë„ ëª¨ë“  outer classì˜ ë©¤ë²„ì— ì ‘ê·¼ ê°€ëŠ¥
        this@Seed.name  eq "Seed"
        this@Fruit.name  eq "Fruit"
      }
    }
  }
}

fun Fruit.grow(amount: Int) {
  absorbWater(amount)
  changeColor("Red") eq "Fruit Red" // Fruit ì˜ changeColor
}

fun Fruit.Seed.grow(n: Int) {
  germinate()
  changeColor("Green") eq "Seed Green" // Fruit.Seedì˜ changeColor
}

fun Fruit.Seed.DNA.grow(n: Int) = n.grow()

fun main() {
  val fruit = Fruit()
  fruit.grow(4)
  val seed = fruit.Seed()
  seed.grow(9)
  seed.whichThis()
  val dna = seed.DNA()
  dna.plant()
  dna.grow(5)
  dna.whichThis()
  dna.changeColor("Purple")
}
```

- inner classëŠ” ë‹¤ë¥¸ outer classì˜ inner classë¥¼ ìƒì†ë°›ì„ ìˆ˜ ìˆë‹¤.

```kotlin
open class Egg {
  private var yolk = Yolk()
  open inner class Yolk {
    init { trace("Egg.Yolk()") }
    open fun f() { trace("Egg.Yolk.f()") }
  }
  init { trace("New Egg()") }
  fun insertYolk(y: Yolk) { yolk = y }
  fun g() { yolk.f() }
}

class BigEgg : Egg() {
  inner class Yolk : Egg.Yolk() { // Eggì˜ inner classì¸ Yolkë¥¼ ìƒì† ë°›ìŒ
    init { trace("BigEgg.Yolk()") }
    override fun f() {
      trace("BigEgg.Yolk.f()")
    }
  }
  init { insertYolk(Yolk()) }
}

fun main() {
  BigEgg().g()
  trace eq """
    Egg.Yolk()
    New Egg()
    Egg.Yolk()
    BigEgg.Yolk()
    BigEgg.Yolk.f()
  """
}
```
- Q. mainì˜ traceê°€ ì™œ ì´ë ‡ê²Œ ì°íˆì§€?? 
  - ì°¸ê³  : ìœ„ ì§ˆë¬¸ì— ëŒ€í•œ ë‹µì„ í•˜ê¸° ì „ì— ì•ì—ì„œ ë°°ìš´ ë‚´ìš©ì„ ë³µìŠµí•´ë³´ì.
    <details>
      <summary>í´ë˜ìŠ¤ ì´ˆê¸°í™” ê³¼ì •</summary>
    
      Â· ì¼ë°˜ì 
      1. ìƒì„±ì íŒŒë¼ë¯¸í„° ëª©ë¡ ì´ˆê¸°í™” 
      2. í”„ë¡œí¼í‹° ì´ˆê¸°í™” 
      3. init ë¸”ë¡ ì‹¤í–‰ 
    
         â†’ ì´ 3ê°€ì§€ ê³¼ì •ì„ `ì£¼ìƒì„±ìê°€ ì‹¤í–‰ëœë‹¤` ë¼ê³  í‘œí˜„í•œë‹¤.
      ---
      
      Â· ìƒì†ì´ ìˆëŠ” ê²½ìš°
      1. ë¶€ëª¨ í´ë˜ìŠ¤ì˜ ì£¼ìƒì„±ì ì‹¤í–‰
      2. ë¶€ëª¨ í´ë˜ìŠ¤ì˜ ë¶€ìƒì„±ì ì‹¤í–‰
      3. ìì‹ í´ë˜ìŠ¤ì˜ ì£¼ìƒì„±ì ì‹¤í–‰
      4. ìì‹ í´ë˜ìŠ¤ì˜ ë¶€ìƒì„±ì ì‹¤í–‰
    </details>
 
- A. `BigEgg().g()`
  1. BigEgg ìƒì„±ì ì‹¤í–‰
  2. BigEggì˜ ë¶€ëª¨í´ë˜ìŠ¤(Egg)ì˜ ì´ˆê¸°í™” ê³¼ì • ì‹¤í–‰
  3. Eggì˜ í”„ë¡œí¼í‹° ì´ˆê¸°í™” 
  4. Yolk ì£¼ìƒì„±ì ì‹¤í–‰(init ë¸”ë¡ ì‹¤í–‰) : `Egg.Yolk()` 
  5. Eggì˜ init ë¸”ë¡ ì‹¤í–‰ : `New Egg()`
  6. BigEggì˜ ì´ˆê¸°í™” ê³¼ì • ì‹¤í–‰
  7. BigEggì˜ init ë¸”ë¡ ì‹¤í–‰ â†’ insertYolk(Yolk()) ì‹¤í–‰
  8. BigEggì˜ inner classì¸ Yolkì˜ ì´ˆê¸°í™” ê³¼ì • ì‹¤í–‰
  9. inner classì¸ Yolkì˜ ë¶€ëª¨í´ë˜ìŠ¤(Egg)ì˜ ì´ˆê¸°í™” ê³¼ì • ì‹¤í–‰
  10. Yolk ì£¼ìƒì„±ì ì‹¤í–‰(init ë¸”ë¡ ì‹¤í–‰) : `Egg.Yolk()`
  11. inner classì¸ Yolkì˜ init ë¸”ë¡ ì‹¤í–‰ : `BigEgg.Yolk()`
  
  â†’ BigEgg classì˜ ì´ˆê¸°í™” ê³¼ì • ë

  12. g() ë©¤ë²„í•¨ìˆ˜ ì‹¤í–‰ â†’ BigEggì— ì—†ìœ¼ë‹ˆ ë¶€ëª¨ í´ë˜ìŠ¤ì¸ Eggì˜ g() ì‹¤í–‰
  13. yolk.f() ì‹¤í–‰ : `Egg.Yolk.f()`


- ì§€ì—­ ë‚´ë¶€ í´ë˜ìŠ¤(Local Inner Class)
  - í´ë˜ìŠ¤ì˜ í•¨ìˆ˜/ë©”ì„œë“œ ë‚´ë¶€ì— ì •ì˜ëœ í´ë˜ìŠ¤
  - ì™¸ë¶€ í´ë˜ìŠ¤ì˜ ë©¤ë²„ì™€ í•¨ìˆ˜ì— ì •ì˜ëœ ë‹¤ë¥¸ ë©¤ë²„ì— ëª¨ë‘ ì ‘ê·¼ì´ ê°€ëŠ¥í•˜ë‹¤.
  - vs ì¤‘ì²© í´ë˜ìŠ¤(nested class)
    - outer classì™€ nested classëŠ” ê°ê° ë…ë¦½ì ì¸ í´ë˜ìŠ¤ë¡œ nested classì—ì„œ outer classì— ì§ì ‘ ì ‘ê·¼(ì°¸ê³ )í•  ìˆ˜ ì—†ë‹¤.

- ìµëª… ë‚´ë¶€ í´ë˜ìŠ¤(Anonymous Inner Class)
  - ë§ê·¸ëŒ€ë¡œ ì´ë¦„ ì—†ì´ ì •ì˜ë˜ëŠ” í´ë˜ìŠ¤ë¡œ **ì¸í„°í˜ì´ìŠ¤ë‚˜ ë‹¤ë¥¸ í´ë˜ìŠ¤ë¥¼ êµ¬í˜„/ìƒì† ë°›ëŠ” ê²½ìš°** ì¼íšŒì„±ìœ¼ë¡œ ìµëª…ì˜ í´ë˜ìŠ¤ë¥¼ ì •ì˜í•˜ê³  ë°”ë¡œ ê°ì²´ë¥¼ ìƒì„±í•œë‹¤.
  - syntax : `object: [ì¸í„°í˜ì´ìŠ¤/ì¶”ìƒí´ë˜ìŠ¤/ìƒì†ë°›ì„ í´ë˜ìŠ¤] { }`

- [ì°¸ê³ ] ë¹„êµ : object í‚¤ì›Œë“œë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒë“¤ 
  - `object { }` : ìµëª… ê°ì²´
  - `object [ê°ì²´ ì´ë¦„] { }` : ì‹±ê¸€í†¤ ê°ì²´
  - `object : [ì¸í„°í˜ì´ìŠ¤/ì¶”ìƒí´ë˜ìŠ¤/ìƒì†ë°›ì„ í´ë˜ìŠ¤ ì´ë¦„] { }` : ìµëª… ë‚´ë¶€ í´ë˜ìŠ¤


```kotlin
fun interface Pet {
  fun speak(): String
}

object CreatePet {
  fun home() = " home!"
  
  fun dog(): Pet {
    val say = "Bark"
    
    // ì§€ì—­ ë‚´ë¶€ í´ë˜ìŠ¤
    class Dog : Pet {
      override fun speak() = say + home()
    }
    return Dog()
  }
  
  fun cat(): Pet {
    val emit = "Meow"
    
    // ìµëª… ë‚´ë¶€ í´ë˜ìŠ¤ â†’ ì¸í…”ë¦¬ì œì´ì—ì„œ ë³´ë©´ ë°‘ì¤„ë¡œ ëŒë‹¤ë¡œ ë³€í™˜í•´ì¤€ë‹¤ëŠ” íŒíŠ¸ë¥¼ ì¤Œ ğŸ’¡
    return object: Pet {
      override fun speak() = emit + home()
    }
  }
  
  fun hamster(): Pet {
    val squeak = "Squeak"
    
    // ìµëª… ë‚´ë¶€ í´ë˜ìŠ¤ì˜ SAM conversion
    return Pet { squeak + home() }
  }
}

fun main() {
  CreatePet.dog().speak() eq "Bark home!"
  CreatePet.cat().speak() eq "Meow home!"
  CreatePet.hamster().speak() eq "Squeak home!"
}
```
- ìµëª… ë‚´ë¶€ í´ë˜ìŠ¤ë¥¼ ëŒë‹¤ë¡œ ë³€í™˜í•˜ë©´ ì•„ë˜ì™€ ê°™ë‹¤. : hamster í•¨ìˆ˜ì™€ ë™ì¼
  ```kotlin
  fun cat(): Pet {
    val emit = "Meow"
    return Pet { emit + home() } // ìµëª… ë‚´ë¶€ í´ë˜ìŠ¤
  }
  ```

- ìš”ì•½ : ì§€ì—­ ë‚´ë¶€ í´ë˜ìŠ¤ vs ìµëª… ë‚´ë¶€ í´ë˜ìŠ¤
  - ê³µí†µì  
    - ëª¨ë‘ ë‚´ë¶€ í´ë˜ìŠ¤ì˜ ì¼ì¢…ìœ¼ë¡œì„œ í´ë˜ìŠ¤ ì™¸ë¶€ì˜ ë©¤ë²„ì™€ ë‚´ë¶€ í´ë˜ìŠ¤ê°€ ì •ì˜ëœ í•¨ìˆ˜ ë‚´ì˜ ë©¤ë²„ì— ì ‘ê·¼ì´ ê°€ëŠ¥
    - í•¨ìˆ˜ê°€ ì‹¤í–‰ë˜ì–´ì•¼ë§Œ ë‚´ë¶€ í´ë˜ìŠ¤ê°€ ìƒì„±ë˜ì–´ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.
  - ì°¨ì´ì  
    - ì´ë¦„ 
      - ì§€ì—­ ë‚´ë¶€ í´ë˜ìŠ¤ëŠ” ë°˜ë“œì‹œ ì´ë¦„ì´ ìˆì–´ì•¼í•œë‹¤. 
      - ìµëª… ë‚´ë¶€ í´ë˜ìŠ¤ëŠ” ì´ë¦„ì´ ì—†ë‹¤.
    - ìš©ë„
      - ì§€ì—­ ë‚´ë¶€ í´ë˜ìŠ¤ : ë©”ì„œë“œ ë‚´ì—ì„œ í´ë˜ìŠ¤ì˜ íŠ¹ì • í–‰ë™ì„ ìº¡ìŠí™”í•˜ê³ ì í•  ë•Œ ì‚¬ìš©, ì´ë¦„ì´ ìˆê¸°ë•Œë¬¸ì— ì¬ì‚¬ìš©ì´ ê°€ëŠ¥í•˜ë‹¤.
      - ìµëª… ë‚´ë¶€ í´ë˜ìŠ¤ : íŠ¹ì • ì¸í„°í˜ì´ìŠ¤ë¥¼ êµ¬í˜„í•˜ê±°ë‚˜ ì¶”ìƒ í´ë˜ìŠ¤ë¥¼ ìƒì†ë°›ëŠ” ì¼íšŒì„± í´ë˜ìŠ¤(ì¬ì‚¬ìš©í•  í•„ìš”ê°€ ì—†ì„ë•Œ)ë¥¼ ì •ì˜í•˜ê³  ì •ì˜ì™€ ë™ì‹œì— ê°ì²´ë¥¼ ìƒì„±í•œë‹¤.


```kotlin
fun interface Counter {
  fun next(): Int
}

object CounterFactory {
  private var count = 0
  fun new(name: String): Counter {
    // Local inner class:
    class Local : Counter {
      init { trace("Local()") }
      override fun next(): Int {
        // Access local identifiers:
        trace("$name $count")
        return count++
      }
    }
    return Local()
  }
  fun new2(name: String): Counter {
    // Instance of an anonymous inner class:
    return object: Counter {
      init { trace("Counter()") }
      override fun next(): Int {
        trace("$name $count")
        return count++
      }
    }
  }
  fun new3(name: String): Counter {
    trace("Counter()")
    return Counter { // SAM conversion
      trace("$name $count")
      count++
    }
  }
}

fun main() {
  fun test(counter: Counter) {
    (0..3).forEach { counter.next() }
  }
  test(CounterFactory.new("Local"))
  test(CounterFactory.new2("Anon"))
  test(CounterFactory.new3("SAM"))
  trace eq """
    Local() Local 0 Local 1 Local 2 Local 3
    Counter() Anon 4 Anon 5 Anon 6 Anon 7
    Counter() SAM 8 SAM 9 SAM 10 SAM 11
  """
}
```

- 

## Atom72 ë™ë°˜ ê°ì²´

```kotlin
class WithCompanion {
  companion object {
    val i = 3
    fun f() = i * 3
  }
  fun g() = i + f()
}

fun WithCompanion.Companion.h() = f() * i

fun main() {
  val wc = WithCompanion()
  wc.g() eq 12
  WithCompanion.i eq 3
  WithCompanion.f() eq 9
  WithCompanion.h() eq 27
}

```

```kotlin
class WithNamed {
  companion object Named {
    fun s() = "from Named"
  }
}

class WithDefault {
  companion object {
    fun s() = "from Default"
  }
}

fun main() {
  WithNamed.s() eq "from Named"
  WithNamed.Named.s() eq "from Named"
  WithDefault.s() eq "from Default"
  // The default name is "Companion":
  WithDefault.Companion.s() eq "from Default"
}

```
```kotlin
class WithObjectProperty {
  companion object {
    private var n: Int = 0 // Only one
  }
  fun increment() = ++n
}

fun main() {
  val a = WithObjectProperty()
  val b = WithObjectProperty()
  a.increment() eq 1
  b.increment() eq 2
  a.increment() eq 3
}

```
```kotlin
class CompanionObjectFunction {
  companion object {
    private var n: Int = 0
    fun increment() = ++n
  }
}

fun main() {
  CompanionObjectFunction.increment() eq 1
  CompanionObjectFunction.increment() eq 2
}

```
```kotlin
class Counted {
  companion object {
    private var count = 0
  }
  private val id = count++
  override fun toString() = "#$id"
}

fun main() {
  List(4) { Counted() } eq "[#0, #1, #2, #3]"
}

```
```kotlin
interface ZI {
  fun f(): String
  fun g(): String
}

open class ZIOpen : ZI {
  override fun f() = "ZIOpen.f()"
  override fun g() = "ZIOpen.g()"
}

class ZICompanion {
  companion object: ZIOpen()
  fun u() = trace("${f()} ${g()}")
}

class ZICompanionInheritance {
  companion object: ZIOpen() {
    override fun g() =
      "ZICompanionInheritance.g()"
    fun h() = "ZICompanionInheritance.h()"
  }
  fun u() = trace("${f()} ${g()} ${h()}")
}

class ZIClass {
  companion object: ZI {
    override fun f() = "ZIClass.f()"
    override fun g() = "ZIClass.g()"
  }
  fun u() = trace("${f()} ${g()}")
}

fun main() {
  ZIClass.f()
  ZIClass.g()
  ZIClass().u()
  ZICompanion.f()
  ZICompanion.g()
  ZICompanion().u()
  ZICompanionInheritance.f()
  ZICompanionInheritance.g()
  ZICompanionInheritance().u()
  trace eq """
    ZIClass.f() ZIClass.g()
    ZIOpen.f() ZIOpen.g()
    ZIOpen.f()
    ZICompanionInheritance.g()
    ZICompanionInheritance.h()
  """
}

```
```kotlin
class ZIClosed : ZI {
  override fun f() = "ZIClosed.f()"
  override fun g() = "ZIClosed.g()"
}

class ZIDelegation {
  companion object: ZI by ZIClosed()
  fun u() = trace("${f()} ${g()}")
}

class ZIDelegationInheritance {
  companion object: ZI by ZIClosed() {
    override fun g() =
      "ZIDelegationInheritance.g()"
    fun h() =
      "ZIDelegationInheritance.h()"
  }
  fun u() = trace("${f()} ${g()} ${h()}")
}

fun main() {
  ZIDelegation.f()
  ZIDelegation.g()
  ZIDelegation().u()
  ZIDelegationInheritance.f()
  ZIDelegationInheritance.g()
  ZIDelegationInheritance().u()
  trace eq """
    ZIClosed.f() ZIClosed.g()
    ZIClosed.f()
    ZIDelegationInheritance.g()
    ZIDelegationInheritance.h()
  """
}
```

```kotlin
interface Extended: ZI {
  fun u(): String
}

class Extend : ZI by Companion, Extended {
  companion object: ZI {
    override fun f() = "Extend.f()"
    override fun g() = "Extend.g()"
  }
  override fun u() = "${f()} ${g()}"
}

private fun test(e: Extended): String {
  e.f()
  e.g()
  return e.u()
}

fun main() {
  test(Extend()) eq "Extend.f() Extend.g()"
}

```
```kotlin
class Numbered2
private constructor(private val id: Int) {
  override fun toString(): String = "#$id"
  companion object Factory {
    fun create(size: Int) =
      List(size) { Numbered2(it) }
  }
}

fun main() {
  Numbered2.create(0) eq "[]"
  Numbered2.create(5) eq
    "[#0, #1, #2, #3, #4]"
}
```
```kotlin
class CompanionInit {
  companion object {
    init {
      trace("Companion Constructor")
    }
  }
}

fun main() {
  trace("Before")
  CompanionInit()
  trace("After 1")
  CompanionInit()
  trace("After 2")
  CompanionInit()
  trace("After 3")
  trace eq """
    Before
    Companion Constructor
    After 1
    After 2
    After 3
  """
}
```

### ìš”ì•½ (Inner Class vs Nested Class vs Companion Object)
```kotlin
fun main() {
    val outer = Outer()
  
    // Inner Class : ë‚´ ì•ˆì— ë„ˆ ìˆë‹¤.
    val inner1 = outer.Inner()
    // val inner2 = Outer.Inner() // ì˜¤ë¥˜
    

    // Nested Class : ë„ˆëŠ” ë„ˆ, ë‚˜ëŠ” ë‚˜
    val nested1 = Outer.Nested()
    // val nested2 = Outer().Nested()

    // Companion Object : ë‚˜ëŠ” ì´ë¯¸ ì¡´ì¬í•œë‹¤.
    val obj1 = Outer.Companion
    // val obj2 = outer.Companion // ì˜¤ë¥˜
}


```


