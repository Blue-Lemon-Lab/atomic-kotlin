# Atom 84 ~ 87

## Atom84

## Atom85

## Atom86 지연계산 초기화

### Recap of Property Initialization

> 지금까지 배운 프로퍼티를 초기화에 대해서 복습해보자

- 직접 초기화
```kotlin
class Person {
    val name:String = "jjanmo" 
}
```
- 생성자를 통한 초기화
```kotlin
class Person(val name:String) {
    
}
```
- init 블럭을 통한 초기화
```kotlin
class Person {
    val name:String // 이런 경우 인텔리제이가 둘을 합치라고 하긴함...
    init{
        name = "jjanmo"
    }
}
```
- custom getter/setter 를 통한 초기화

```kotlin
class Person {
    val name: String 
        get() = "Anonymous"
}
```
> 이런 경우 name의 활용도가 없다

```kotlin
class Person {
    var name: String = "Anonymous"
        get() = field.uppercase()
        set(value) {
            field = value.trim()
        }
}
```
### 지연 계산 초기화

> 프로퍼티를 초기화시키는 또 다른 방법

- 문제상황
  - 프로퍼티의 값을 초기화 시키기 위해서 **아래와 같은 상황들**이 필요한 경우가 있다.
    - 복잡하고 시간이 오래걸리는 계산을 통한 프로퍼티 초기화
    - 네트워크 요청에서 받아온 데이터를 통한 프로퍼티 초기화 
    - 데이터베이스에서 받아온 데이터를 통한 프로퍼티 초기화
  
    → 이런 과정의 초기화들은 **문제**를 발생시킬 수 있다
  
    - 어플리케이션의 초기 시작 시간이 오래 걸릴 수 있다.
    - 어플리케이션 초기에 사용할 필요가 없는 값(나중에 사용해도 되는 값)을 초기화 시키는 경우가 생긴다. : 초기시점의 리소스의 낭비
- 해결책
  - 코틀린에서 내부적으로 **지연 계산읕 통한 프로퍼티 초기화** 기능 제공 
  - 해당 기능을 사용하는 프로퍼티는 프로퍼티가 사용될 때 초기화 된다.

### 사용법(Syntax)

```kotlin
val lazyProperty by lazy {
    // 초기화코드
}
```
- 앞서배운 **프로퍼티 위임**(Atom84)를 통해 일관성 있고 알아보기 쉬운 지연계산 프로퍼티 구문을 제공 
- lazy() 함수를 람다로 쓴 것으로서 초기화가 필요한 시점(프로퍼티가 사용되는 시점)에 람다를 실행시켜서 초기화를 시킨다. 그 후 같은 프로퍼티를 사용하는 경우 캐싱된 값을 불러오게 된다.(람다는 초기화 시점에 한 번만 실행된다) 

```kotlin
val idle: String by lazy {
  trace("Initializing 'idle'")
  "I'm never used"
}

val helpful: String by lazy {
  trace("Initializing 'helpful'")
  "I'm helping!"
}

fun main() {
  trace(helpful) // helpful이 사용되어 아래 문자열이 출력됨 / idle은 사용되지 않기 때문에 출력되지않음
  trace eq """
    Initializing 'helpful'
    I'm helping!
  """
}
```
- 지연계산 초기화로 인해서 변수는 `val`로 사용가능하다.

### 작동방식
```kotlin
class LazyInt(val init: () -> Int) {
  private var helper: Int? = null
  val value: Int
    get() {
      if (helper == null) helper = init()
      return helper!!
    }
}

fun main() {
  val later = LazyInt {
    trace("Initializing 'later'")
    5
  }
  trace("First 'value' access:")
  trace(later.value)
  trace("Second 'value' access:")
  trace(later.value)
  trace eq """
    First 'value' access:
    Initializing 'later'
    5
    Second 'value' access:
    5
  """
}
```
- 위의 LazyInt 클래스는 lazy() 함수의 작동방식을 모킹한 코드이다. init 함수를 인자로 받고 helper가 null이면 초기화를 시킨 후 helper를 반환한다. helper가 존재하면 그 뒤로는 init()를 실행하지 않고 helper를 반환한다.즉 처음에 초기화시킨 값을 계속해서 반환하는 것이다.

### 프로퍼티 초기화 방법 비교

> 프로퍼티 정의 시점 vs 게터를 사용한 초기화 시점 vs 지연 계산을 통한 초기화 시점 

```kotlin
fun compute(i: Int): Int { 
  trace("Compute $i")
  return i
}

object Properties {
  val atDefinition = compute(1) // 정의시점의 초기화
  val getter
    get() = compute(2) // 커스텀게터를 통한 초기화
  val lazyInit by lazy { compute(3) } // 지연계산을 통한 초기화
  val never by lazy { compute(4) }
}

fun main() {
  listOf(
    Properties::atDefinition, 
    Properties::getter, 
    Properties::lazyInit 
  ).forEach {
    trace("${it.name}:")
    trace("${it.get()}")
    trace("${it.get()}")
  }
  trace eq """
    Compute 1 // 객체 Properties가 정의될 때, 프로퍼티도 atDefinition 같이 정의되기 때문에 함수 compute가 실행되면서 출력됨
    
    ✅ 여기서부터가 forEach를 돌면서 찍히는 값
    
    atDefinition: // 참조한 함수 이름
    1 // 초기화된 값을 가져와서 출력되기 때문에 compute가 재실행되지 않음
    1
    
    getter: // 참조한 함수 이름
    // getter 를 실행시킨다는 의미는 결국 함수 compute를 실행시킨다는 것과 동일하여 2번의 getter를 호출하기때문에 2번의 [Compute 2, 2] 가 출력됨
    Compute 2 
    2
    Compute 2
    2
    
    lazyInit: // 참조한 함수 이름
    // 지연 계산 초기화이기 때문에 실제 값이 쓰일때 초기화가 이루어짐. 그래서 첫번째 접근시에만 함수 compute가 실행되었고 두번째 접근시에는 캐싱된 값만을 가져와서 사용함 
    Compute 3 
    3
    3
    
    // never 프로퍼티에는 접근하지 않아서 노출되지 않음
  """
}
```

## Atom87 늦은 초기화

> 앞서 배운 지연 계산과 같은 목적을 가지고 탄생한 기능이지만, 상황과 사용 목적이 살짝 다르다. 어떻게 다른지에 초점을 맞추고 알아보자
 

- 문제상황
  - 어떤 재사용가능한 라이브러리가 존재한다고 가정

  ```kotlin
  interface Bag {
    fun setUp() // "인스턴스를 초기화하는 함수"가 존재 + setUp의 "호출을 보장"
  }
  
  class Suitcase : Bag { // Bag를 구현한 클래스
    private var items: String? = null 
    override fun setUp() { 
      items = "socks, jacket, laptop"
    }
    fun checkSocks(): Boolean = items?.contains("socks") ?: false
  }
  
  fun main() {
    val suitcase = Suitcase()
    suitcase.setUp()
    suitcase.checkSocks() eq true
  }
  ```
  - 클래스 Suitcase 에서 setUp을 오버라이드할 때, 프로퍼티를 초기화해줘여한다.
  - 하지만 items를 그냥 String으로 정의할 수 없음 : String으로 정의하려면 초기화 단계에서 값을 할당해줘야한다.
  - 결국 null을 사용하여 초기화 안되었음을 나타내줘야하고 `String?` 
    → 문제의 시작
  - items를 사용하기 위해선 items가 null이 아닌지 여부를 항상 체크해줘야한다. : `checkSocks`
  - 그런데 상황상 생각해보면, **항상 setup의 호출은 보장한다(초기화를 한다)**가 전제조건이기 때문에 객체를 사용한다는 건 결국 이미 items는 초기화가 되어있는 상태인데, 굳이 items의 null 체크를 해야하나?! 라는 문제가 발생 + 이를 사용하는 모든 코드로 해당 문제가 전파된다

- 문제해결 by `lateinit`

  ```kotlin
  class BetterSuitcase : Bag {
    lateinit var items: String 
    override fun setUp() {
      items = "socks, jacket, laptop"
    }
    fun checkSocks() = "socks" in items
  }
  
  fun main() {
    val suitcase = BetterSuitcase()
    suitcase.setUp()
    suitcase.checkSocks() eq true
  }
  ```
  - `lateinit` 이라는 키워드를 붙이면 아까와 다르게 null 타입이 아닌 타입을 사용하는게 가능해진다.
    - 즉, items를 안전하게 널이 아닌 프로퍼티로 선언해도 된다는 의미
  - `lateinit`의 제약사항
    - var 프로퍼티에만 적용 가능, val 프로퍼티에는 적용 불가능
    - 프로퍼티 타입은 null이 아닌 타입이고 원시타입이 아니여야한다.
      - 코틀린에서 원시타입 : Int, Char, Double 등
    - 추상 클래스의 추상 프로퍼티나 **_인스턴스의 프로퍼티_**에는 적용 불가능
      - Q. 책에서 이야기하는 인스턴스의 프로퍼티가 무엇을 말하는지 모르겠음. 찾아보면 일반 클래스의 프로퍼티 같은데 그렇게 이해하면 위에서 언급한 것과 반대인거라서...음 🤔


- lateinit인데 프로퍼티를 초기화시키지 않는다면,
  ```kotlin
  class FaultySuitcase : Bag {
    lateinit var items: String
    override fun setUp() {}
    fun checkSocks() = "socks" in items
  }
  
  fun main() {
    val suitcase = FaultySuitcase()
    suitcase.setUp()
    capture {
      suitcase.checkSocks()
    } eq
      "UninitializedPropertyAccessException" +
      ": lateinit property items " +
      "has not been initialized"
  }
  ```
  - 컴파일상에서는 오류가 나오지 않는다 : 코틀린이 검사할 수 없는 복잡한 로직 혹은 다른 프로퍼티에 의존할 수 도 있다고 판단
  - 하지만 실행시점(런타임)에 오류가 발생
  
- `isInitialized` 속성
  - `lateInit` 프로퍼티에는 컴파일러에 의해서 읽기 전용 속성으로 `isInitialized`이 자동 생성된다.
  - 해당 프로퍼티가 초기화 되었는지 여부를 판단할 수 있다.

  ```kotlin
  class WithLate {
    lateinit var x: String
    fun status() = "${::x.isInitialized}" // 앞에 this가 생략되어있는 것 : this::x.isInitialized
  }
  
  lateinit var y: String
  
  fun main() {
    trace("${::y.isInitialized}") // false  // main 함수에서는 this가 없고 전역 프로퍼티인 y를 참조하고 있는 것 
    y = "Ready"
    trace("${::y.isInitialized}") // true
    val withlate = WithLate() 
    trace(withlate.status()) // false
    withlate.x = "Set"
    trace(withlate.status()) // true
    trace eq "false true false true"
  }
  ```
- 여기서 궁금한 것 :  `::` 는 뭐지??
  ```kotlin
  class Person {
      lateinit var name: String  
  }
  
  fun main() {
      val person = Person()
      println(person::name.isInitialized) // 1)
     //  println(person.name.isInitialized) // 오류 // 2)
  }
  ```
 - 첫번째는 **리플렉션**를 사용한 프로퍼티 참조, 두번째는 직접 프로퍼티 참조이라고 한다. 
 - 리플렉스(Reflection)
   - 프로그램 실행 중에 타입, 메서드, 필드, 프로퍼티 등의 구조에 대한 정보를 동적으로 조회하거나 수정할 수 있는 기능
   - `isInitialized` 는 프로그램이 실행 중에 초기화가 되면 동적으로, 내부적으로 변경되는 값에 해당하기 때문에 리플렉션을 이용하여 접근해야 가능하다.

  - 1), 2)위에 아래 이미지와 같은 메시지가 뜬다. 자세한 내용(타입적인 부분들)에 대해선 파악하지 않았고 저런것들이 있구나 정도로만 우선 알고 넘어가자!
    - 여러가지 데코레이터가 나오는데 궁금하긴하넹 : `@SinceKotlin`, `@InlineOnly`, `@receiver`
  
  ![atom87_1](/screenshots/atom87_1.png)
  > `person::name.isInitialized`
  
  ![atom87_2](/screenshots/atom87_2.png)
  > `person.name.isInitialized`



