# Atomic Kotlin 26 ~ 30

<details>
  <summary>Collection Hierarchy</summary>

![collection-hierarchy](../screenshots/collection-hierarchy.png)

- Red Box : 여기서 배울 Collection들
- Blue Box : 여기선 배우지않지만 다양한 Map의 종류 ([관련링크](https://medium.com/depayse/kotlin-collections-2-map-hashmap-treemap-linkedhashmap-76195842f0c8))

</details>

## Atom26 집합(Set)

- Set의 생성 : 리스트와 마찬가지로 두가지 생성함수 제공

  - `setOf()` → 읽기전용 Set
  - `mutableSetOf()` → 가변 Set

- Set 의 특징

  ```kotlin
  fun main() {
    // 1
    val intSet = setOf(1, 1, 2, 3, 9, 9, 4)
    intSet eq setOf(1, 2, 3, 4, 9)

    // 2
    setOf(1, 2) eq setOf(2, 1)

    // 3
    (9 in intSet) eq true
    (99 in intSet) eq false

    intSet.contains(9) eq true
    intSet.contains(99) eq false

    // 4
    intSet.containsAll(setOf(1, 9, 2)) eq true

    // 5 : 합집합
    intSet.union(setOf(3, 4, 5, 6)) eq
      setOf(1, 2, 3, 4, 5, 6, 9)

    // 6 : 교집합
    intSet intersect setOf(0, 1, 2, 7, 8) eq
      setOf(1, 2)

    // 7 : 차집합
    intSet subtract setOf(0, 1, 9, 10) eq
      setOf(2, 3, 4)
    intSet - setOf(0, 1, 9, 10) eq
      setOf(2, 3, 4)
  }

  ```

  - 중복되지 않는다.
  - 순서가 없다
  - `in`, `contains()`를 통해서 요소인지 여부를 확인할 수 있다.
  - `containsAll()` 를 통해서 Set끼리의 포함여부를 확인할 수 있다.
  - Set의 연산 지원(밴 다이어그램 연산)
    - 합집합(union, +), 교집합(intersect), 차집합(subtract, -)
      - 점표기법 : `set1.union(set2)`
      - 중위표기법 : `set1 union set2`, `set1 + set2`

- 중복제거에서의 Set 활용

  ```kotlin
    fun main() {
      val list = listOf(3, 3, 2, 1, 2)
      list.toSet() eq setOf(1, 2, 3)
      list.distinct() eq listOf(3, 2, 1)
      "abbcc".toSet() eq setOf('a', 'b', 'c')
    }
  ```

  - 리스트에서 집합으로 변경하여 중복을 제거할 수 있다.
    - `toSet()` 이용
  - `distinct()` 를 이용하여 중복을 제거할 수 있다.
    - Array, List에서 사용하여 중복을 제거한 Array 나 List를 반환한다. 단, 순서는 유지된다.
    - Set에서도 distinct() 멤버함수 존재하지만, Set의 특성상 의미없는 멤버함수이다. 단지 Collection 인터페이스에서 상속되어서 있는 것이다.
  - `문자열.toSet()` 을 통해서도 중복을 제거할 수 있다.

  - 위의 내용을 활용한 문자열의 중복을 없애는 또다른 방법
    ```kotlin
      val b = "helloworld".toList()
      val c = b.distinct()
      println(c)
    ```
    > 당연하게도 타입은 다름!

- MutableSet

  - 리스트와 마찬가지로 +/- 연산을 통해서 원소를 추가 삭제가 가능하다.

    ```kotlin
      fun main() {
        val mutableSet = mutableSetOf<Int>()
        mutableSet += 42
        mutableSet += 42
        mutableSet eq setOf(42)
        mutableSet -= 42
        mutableSet eq setOf<Int>()
      }
    ```

<details>
  <summary>참고</summary>

```kotlin
fun main() {
    val list = mutableListOf(1,2,3,4) // o.k
    var list = mutableListOf(1,2,3,4) // o.k
    val list = listOf(1,2,3,4) // val not reassign
    var list = listOf(1,2,3,4) // o.k
    list += 5
    println(list)
    list -= 1
    println(list)
}
```

> [실행링크](https://pl.kotl.in/ij3t9Mgxs)

현상적으로만 따지면, val에 할당하고 읽기전용 생성함수인 listOf로 생성하는 경우에만 연산이 불가능하다.

</details>

## Atom27 맵

> 맵은 키와 값을 연결시켜주기 때문에 이를 `연관 배열(associative array)` 라고 부르기도 한다.

- Map의 생성

  - 키-값 쌍을 mapOf()에 전달
  - 키-값 전달 형식 : `키 to 값`

  ```kotlin
  fun main() {
      val constants = mapOf(
      "Pi" to 3.141,
      "e" to 2.718,
      "phi" to 1.618
    )
    constants eq
      "{Pi=3.141, e=2.718, phi=1.618}"
  }
  ```

- Map의 특징

  ```kotlin
  fun main() {

  // 1) 접근
  constants["e"] eq 2.718
  constants.keys eq setOf("Pi", "e", "phi")
  constants.values eq "[3.141, 2.718, 1.618]"

  // 2) 반복1
  var s = ""
  for (entry in constants) {
    s += "${entry.key}=${entry.value}, "
  }
  s eq "Pi=3.141, e=2.718, phi=1.618,"


  // 3) 반복2
  s = ""
  for ((key, value) in constants)
    s += "$key=$value, "
  s eq "Pi=3.141, e=2.718, phi=1.618,"
  }
  ```

  - 접근

    - `map[특정키]` : 특정 키를 가진 값을 얻을 수 있다.
    - `map.keys` : map의 모든 키를 가져온다.

      → 하나의 map안에서 키는 유일하기 때문에 결국 Set이 생성된다. 실제로 리턴 타입도 Set이다.

      ```kotlin
      public val keys: Set<K>
      ```

    - `map.values` : map의 모든 값을 가져온다.

      ```kotlin
      public val values: Collection<V>
      ```

  - 반복(Iterate)

    - `for (entry in constants)` : for loop
      - `entry.key` : 키
      - `entry.value` : 값
    - `for ((key, value) in constants)` : unpacking for loop
      - key, value 로 직접 접근

- MutableMap

  ```kotlin
    fun main() {
      val m =
        mutableMapOf(5 to "five", 6 to "six")
      m[5] eq "five"

      m[5] = "5ive"
      m[5] eq "5ive"

      m += 4 to "four"
      m eq mapOf(5 to "5ive",
        4 to "four", 6 to "six")
    }
  ```

  - `m[5] = "5ive"` : 기존 5 를 변경할 수 있다.
  - `m += 4 to "four"` : 명시적으로 키와 값을 추가할 수 있다.
  - mapof(), mutableMapOf()는 Map에 전달된 순서를 유지해주지만, 다른 Map(상단의 hierarchy 참고)에서는 순서가 보장되지 않을 수 있다.

- ReadOnlyMap

  ```kotlin
    fun main() {
      val m = mapOf(5 to "five", 6 to "six")
      m[5] eq "five"

      // m[5] = "5ive" // 불가능
      // m += (4 to "four") // 불가능
      m + (4 to "four") // m을 변경할 수 없음
      m eq mapOf(5 to "five", 6 to "six")

      val m2 = m + (4 to "four")
      m2 eq mapOf(
        5 to "five", 6 to "six", 4 to "four")
  }
  ```

  - 읽기전용 Map : 수정, 추가 불가능
  - 읽기전용 Map에서 키-값을 추가하는 방법은 새로운 Map을 생성해야한다.

- 맵의 기본값 설정

  ```kotlin
  fun main() {
    val map = mapOf('a' to "attempt")
    map['b'] eq null

    capture {
      map.getValue('b')
    } eq "NoSuchElementException: " +
      "Key b is missing in the map."

    map.getOrDefault('a', "??") eq "attempt"
    map.getOrDefault('b', "??") eq "??"
  }
  ```

  - Map에서 특정 키로 접근할때, 키에 대한 값이 없으면 null을 반환한다.
  - `getValue()` 멤버함수를 사용하여 접근하면, 값이 없으면 `NoSuchElementException` 를 반환한다.
  - 가장 좋은 방법은 `getOrDefault(key, defaultValue)` 를 사용하는 것이다. 키로 접근할 때, 값이 없으면, 설정된 기본값을 반환한다.

- 클래스 인스턴스를 Map에 저장하는 방법

  ```kotlin
  class Contact(
    val name: String,
    val phone: String
  ) {
    override fun toString(): String {
      return "Contact('$name', '$phone')"
    }
  }

  fun main() {
    val miffy = Contact("Miffy", "1-234-567890")
    val cleo = Contact("Cleo", "098-765-4321")
    val contacts = mapOf(
      miffy.phone to miffy,
      cleo.phone to cleo)
    contacts["1-234-567890"] eq miffy
    contacts["1-111-111111"] eq null
  }
  ```

  - `miffy` 와 `cleo` 인스턴스 생성
  - 각 전화번호에 맞는 인스턴스를 저장할 수 있다.(인스턴스 맵핑)

    → 인스턴스를 키로 사용할 수 있는데, 이 방법은 뒤에서 학습

## Atom28 프로퍼티 접근자

## Atom29 : 2부 요약

### 패키지와 테스트

### 객체는 모든 곳에 존재한다

### 클래스 만들기

### 생성자

### 가시성 제한하기

### 예외

### 리스트

### 파라미터화한 타입

### 가변인자 목록

### 집합

### 맵

### 프로퍼티 접근자

## Atom30 확장 함수

- 확장 함수(extension function) 정의

  - 기존 클래스에서 멤버 함수를 추가하는 것과 같은 효과를 내는 함수를 확장 함수라고 한다. 그래서 마치 기존 클래스의 멤버 함수처럼 호출해서 사용할 수 있다.

  - `fun 수신타입.확장함수() { .... }`

    - 정의에서 적힌 수신 타입 이란 : 확장할 대상 타입을 의미하고, 수식 객체 타입(receiver type)이라고 부른다.(줄여서 수신 타입)

  ```kotlin
  fun String.singleQuote() = "'$this'"
  fun String.doubleQuote() = "\"$this\""

  fun main() {
    "Hi".singleQuote() eq "'Hi'"
    "Hi".doubleQuote() eq "\"Hi\""
  }
  ```

- 임포트 방법

  ```kotlin
    import atomictest.eq
    import extensionfunctions.doubleQuote // ✅
    import extensionfunctions.singleQuote // ✅

    fun main() {
      "Single".singleQuote() eq "'Single'"
      "Double".doubleQuote() eq "\"Double\""
    }
  ```

- 확장 함수에서의 this

  - 클래스 내부에서 this를 생략가능한 것과 마찬가지로 확장 함수에서도 생략 가능

  ```kotlin
    fun String.strangeQuote() =
      this.singleQuote().singleQuote()

    fun String.tooManyQuotes() =
      doubleQuote().doubleQuote()

    fun main() {
      "Hi".strangeQuote() eq "''Hi''"
      "Hi".tooManyQuotes() eq "\"\"Hi\"\""
    }
  ```

- ```kotlin

  class Book(val title: String)

  fun Book.categorize(category: String) =
    """title: "$title", category: $category"""

  fun main() {
    Book("Dracula").categorize("Vampire") eq
      """title: "Dracula", category: Vampire"""
  }
  ```
