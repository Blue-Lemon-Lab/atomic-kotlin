# Atomic Kotlin 26 ~ 30

<details>
  <summary>Collection Hierarchy</summary>

![collection-hierarchy](../screenshots/collection-hierarchy.png)

- Red Box : 여기서 배울 Collection들
- Blue Box : 여기선 배우지않지만 다양한 Map의 종류 ([관련링크](https://medium.com/depayse/kotlin-collections-2-map-hashmap-treemap-linkedhashmap-76195842f0c8))

</details>

## Atom26 집합(Set)

- Set의 생성 : 리스트와 마찬가지로 두가지 생성함수 제공

  - `setOf()` → 읽기전용 Set
  - `mutableSetOf()` → 가변 Set

- Set 의 특징

  ```kotlin
  fun main() {
    // 1
    val intSet = setOf(1, 1, 2, 3, 9, 9, 4)
    intSet eq setOf(1, 2, 3, 4, 9)

    // 2
    setOf(1, 2) eq setOf(2, 1)

    // 3
    (9 in intSet) eq true
    (99 in intSet) eq false

    intSet.contains(9) eq true
    intSet.contains(99) eq false

    // 4
    intSet.containsAll(setOf(1, 9, 2)) eq true

    // 5 : 합집합
    intSet.union(setOf(3, 4, 5, 6)) eq
      setOf(1, 2, 3, 4, 5, 6, 9)

    // 6 : 교집합
    intSet intersect setOf(0, 1, 2, 7, 8) eq
      setOf(1, 2)

    // 7 : 차집합
    intSet subtract setOf(0, 1, 9, 10) eq
      setOf(2, 3, 4)
    intSet - setOf(0, 1, 9, 10) eq
      setOf(2, 3, 4)
  }

  ```

  - 중복되지 않는다.
  - 순서가 없다
  - `in`, `contains()`를 통해서 요소인지 여부를 확인할 수 있다.
  - `containsAll()` 를 통해서 Set끼리의 포함여부를 확인할 수 있다.
  - Set의 연산 지원(밴 다이어그램 연산)
    - 합집합(union, +), 교집합(intersect), 차집합(subtract, -)
      - 점표기법 : `set1.union(set2)`
      - 중위표기법 : `set1 union set2`, `set1 + set2`

- 중복제거에서의 Set 활용

  ```kotlin
    fun main() {
      val list = listOf(3, 3, 2, 1, 2)
      list.toSet() eq setOf(1, 2, 3)
      list.distinct() eq listOf(3, 2, 1)
      "abbcc".toSet() eq setOf('a', 'b', 'c')
    }
  ```

  - 리스트에서 집합으로 변경하여 중복을 제거할 수 있다.
    - `toSet()` 이용
  - `distinct()` 를 이용하여 중복을 제거할 수 있다.
    - Array, List에서 사용하여 중복을 제거한 Array 나 List를 반환한다. 단, 순서는 유지된다.
    - Set에서도 distinct() 멤버함수 존재하지만, Set의 특성상 의미없는 멤버함수이다. 단지 Collection 인터페이스에서 상속되어서 있는 것이다.
  - `문자열.toSet()` 을 통해서도 중복을 제거할 수 있다.

  - 위의 내용을 활용한 문자열의 중복을 없애는 또다른 방법
    ```kotlin
      val b = "helloworld".toList()
      val c = b.distinct()
      println(c)
    ```
    > 당연하게도 타입은 다름!

- MutableSet

  - 리스트와 마찬가지로 +/- 연산을 통해서 원소를 추가 삭제가 가능하다.

    ```kotlin
      fun main() {
        val mutableSet = mutableSetOf<Int>()
        mutableSet += 42
        mutableSet += 42
        mutableSet eq setOf(42)
        mutableSet -= 42
        mutableSet eq setOf<Int>()
      }
    ```

<details>
  <summary>참고</summary>

```kotlin
fun main() {
    val list = mutableListOf(1,2,3,4) // o.k
    var list = mutableListOf(1,2,3,4) // o.k
    val list = listOf(1,2,3,4) // val not reassign
    var list = listOf(1,2,3,4) // o.k
    list += 5
    println(list)
    list -= 1
    println(list)
}
```

> [실행링크](https://pl.kotl.in/ij3t9Mgxs)

현상적으로만 따지면, val에 할당하고 읽기전용 생성함수인 listOf로 생성하는 경우에만 연산이 불가능하다.

</details>

## Atom27 맵

> 맵은 키와 값을 연결시켜주기 때문에 이를 `연관 배열(associative array)` 라고 부르기도 한다.

- Map의 생성

  - 키-값 쌍을 mapOf()에 전달
  - 키-값 전달 형식 : `키 to 값`

  ```kotlin
  fun main() {
      val constants = mapOf(
      "Pi" to 3.141,
      "e" to 2.718,
      "phi" to 1.618
    )
    constants eq
      "{Pi=3.141, e=2.718, phi=1.618}"
  }
  ```

- Map의 특징

  ```kotlin
  fun main() {

  // 1) 접근
  constants["e"] eq 2.718
  constants.keys eq setOf("Pi", "e", "phi")
  constants.values eq "[3.141, 2.718, 1.618]"

  // 2) 반복1
  var s = ""
  for (entry in constants) {
    s += "${entry.key}=${entry.value}, "
  }
  s eq "Pi=3.141, e=2.718, phi=1.618,"


  // 3) 반복2
  s = ""
  for ((key, value) in constants)
    s += "$key=$value, "
  s eq "Pi=3.141, e=2.718, phi=1.618,"
  }
  ```

  - 접근

    - `map[특정키]` : 특정 키를 가진 값을 얻을 수 있다.
    - `map.keys` : map의 모든 키를 가져온다.

      → 하나의 map안에서 키는 유일하기 때문에 결국 Set이 생성된다. 실제로 리턴 타입도 Set이다.

      ```kotlin
      public val keys: Set<K>
      ```

    - `map.values` : map의 모든 값을 가져온다.

      ```kotlin
      public val values: Collection<V>
      ```

  - 반복(Iterate)

    - `for (entry in constants)` : for loop
      - `entry.key` : 키
      - `entry.value` : 값
    - `for ((key, value) in constants)` : unpacking for loop
      - key, value 로 직접 접근

- MutableMap

  ```kotlin
    fun main() {
      val m =
        mutableMapOf(5 to "five", 6 to "six")
      m[5] eq "five"

      m[5] = "5ive"
      m[5] eq "5ive"

      m += 4 to "four"
      m eq mapOf(5 to "5ive",
        4 to "four", 6 to "six")
    }
  ```

  - `m[5] = "5ive"` : 기존 5 를 변경할 수 있다.
  - `m += 4 to "four"` : 명시적으로 키와 값을 추가할 수 있다.
  - mapof(), mutableMapOf()는 Map에 전달된 순서를 유지해주지만, 다른 Map(상단의 hierarchy 참고)에서는 순서가 보장되지 않을 수 있다.

- ReadOnlyMap

  ```kotlin
    fun main() {
      val m = mapOf(5 to "five", 6 to "six")
      m[5] eq "five"

      // m[5] = "5ive" // 불가능
      // m += (4 to "four") // 불가능
      m + (4 to "four") // m을 변경할 수 없음
      m eq mapOf(5 to "five", 6 to "six")

      val m2 = m + (4 to "four")
      m2 eq mapOf(
        5 to "five", 6 to "six", 4 to "four")
  }
  ```

  - 읽기전용 Map : 수정, 추가 불가능
  - 읽기전용 Map에서 키-값을 추가하는 방법은 새로운 Map을 생성해야한다.

- 맵의 기본값 설정

  ```kotlin
  fun main() {
    val map = mapOf('a' to "attempt")
    map['b'] eq null

    capture {
      map.getValue('b')
    } eq "NoSuchElementException: " +
      "Key b is missing in the map."

    map.getOrDefault('a', "??") eq "attempt"
    map.getOrDefault('b', "??") eq "??"
  }
  ```

  - Map에서 특정 키로 접근할때, 키에 대한 값이 없으면 null을 반환한다.
  - `getValue()` 멤버함수를 사용하여 접근하면, 값이 없으면 `NoSuchElementException` 를 반환한다.
  - 가장 좋은 방법은 `getOrDefault(key, defaultValue)` 를 사용하는 것이다. 키로 접근할 때, 값이 없으면, 설정된 기본값을 반환한다.

- 클래스 인스턴스를 Map에 저장하는 방법

  ```kotlin
  class Contact(
    val name: String,
    val phone: String
  ) {
    override fun toString(): String {
      return "Contact('$name', '$phone')"
    }
  }

  fun main() {
    val miffy = Contact("Miffy", "1-234-567890")
    val cleo = Contact("Cleo", "098-765-4321")
    val contacts = mapOf(
      miffy.phone to miffy,
      cleo.phone to cleo)
    contacts["1-234-567890"] eq miffy
    contacts["1-111-111111"] eq null
  }
  ```

  - `miffy` 와 `cleo` 인스턴스 생성
  - 각 전화번호에 맞는 인스턴스를 저장할 수 있다.(인스턴스 맵핑)

    → 인스턴스를 키로 사용할 수 있는데, 이 방법은 뒤에서 학습

## Atom28 프로퍼티 접근자

> 클래스 내부에 선언된 프로퍼티에 대한 `getter`와 `setter` 를 어떻게 사용하는지에 대해서 알아본다.

- 프로퍼티 접근

  ```kotlin
    class Data(var i: Int)

    fun main() {
      val data = Data(10)
      data.i eq 10  // get
      data.i = 20   // set
    }
  ```

  - 인스턴스 내부의 프로퍼티를 통해서 `get`과 `set`을 할 수 있다.

- 프로퍼티 접근 커스터마이징

  ```kotlin
  class Default {
    var i: Int = 0
      get() {
        trace("get()")
        return field
      }
      set(value) {
        trace("set($value)")
        field = value
      }
  }

  fun main() {
    val d = Default()
    d.i = 2
    trace(d.i)
    trace eq """
      set(2)
      get()
      2
    """
  }
  ```

  - 클래스 내부에서 프로퍼티 정의 이후에 `getter`와 `setter`를 정의할 수 있다.
  - getter와 setter를 정의하는 순서는 중요하지 않다.
  - getter와 setter 내부에만 존재하는 `field` 라는 이름을 사용해 저장된 값에 직접 접근 가능하다.
  - getter와 setter 안에서 커스터마이징이 가능하다. 위에서는 값을 읽고 쓰는 과정에서 추가 정보가 출력될 수 있도록 만든 것이다.

- private

  ```kotlin
  class Counter {
    var value: Int = 0 // ✅
      private set      // ✅
    fun inc() = value++
  }

  fun main() {
    val counter = Counter()

    // counter.value++

    repeat(10) {
      counter.inc()
    }
    counter.value eq 10
  }
  ```

  - value에 대한 접근자 모두 private 설정 : `private var value: Int = 0`
  - 위 코드는 `getter는 public`이고 `setter는 private` 으로 설정한 것으로 들여쓰기 형식을 맞춰야하는 것으로 보인다.(인텔리제이에서 자동으로 들여쓰기됨)
  - [TEST] `counter.value++` → error : Cannot assign to 'value': the setter is private in 'Counter'

- field를 사용하지 않는 접근자

  ```kotlin
  class Hamster(val name: String)

  class Cage(private val maxCapacity: Int) {
    private val hamsters =
      mutableListOf<Hamster>()

    val capacity: Int
      get() = maxCapacity - hamsters.size
    val full: Boolean
      get() = hamsters.size == maxCapacity

    fun put(hamster: Hamster): Boolean =
      if (full)
        false
      else {
        hamsters += hamster
        true
      }
    fun take(): Hamster =
      hamsters.removeAt(0)
  }

  fun main() {
    val cage = Cage(2)
    cage.full eq false
    cage.capacity eq 2
    cage.put(Hamster("Alice")) eq true
    cage.put(Hamster("Bob")) eq true
    cage.full eq true
    cage.capacity eq 0
    cage.put(Hamster("Charlie")) eq false
    cage.take()
    cage.capacity eq 1
  }
  ```

  - `full` 과 `capacity` 는 내부 프로퍼티 값을 이용해서 getter를 정의하고 있다.

- 리팩토링

  ```kotlin
  class Cage2(private val maxCapacity: Int) {
    private val hamsters =
      mutableListOf<Hamster>()
    fun capacity(): Int =
      maxCapacity - hamsters.size
    fun isFull(): Boolean =
      hamsters.size == maxCapacity
  }
  ```

  - 위에서 `full` 과 `capacity` 를 프로퍼티를 멤버함수로 변경할 수 있다.
  - 프로퍼티 vs 멤버함수??
    - 코틀린 스타일 가이드에서는 계산비용이 많지않고, 객체상태를 변경하지 않는 한 멤버함수보다는 **프로퍼티**를 사용할 것을 추천

## Atom29 : 2부 요약

### 패키지와 테스트

### 객체는 모든 곳에 존재한다

### 클래스 만들기

### 생성자

### 가시성 제한하기

### 예외

### 리스트

### 파라미터화한 타입

### 가변인자 목록

### 집합

### 맵

### 프로퍼티 접근자

## Atom30 확장 함수

- 확장 함수(extension function) 정의

  ```kotlin
  fun String.singleQuote() = "'$this'"
  fun String.doubleQuote() = "\"$this\""

  fun main() {
    "Hi".singleQuote() eq "'Hi'"
    "Hi".doubleQuote() eq "\"Hi\""
  }
  ```

  - 기존 클래스에서 멤버 함수를 추가하는 것과 같은 효과를 내는 함수를 확장 함수라고 한다. 그래서 마치 기존 클래스의 멤버 함수처럼 호출해서 사용할 수 있다.

  - `fun 수신타입.확장함수() { .... }`

    - 정의에서 적힌 **수신타입** 이란 : 확장할 대상 타입을 의미하고, 수식 객체 타입(receiver type)이라고 부른다.

- 임포트 방법

  ```kotlin
    import atomictest.eq
    import extensionfunctions.doubleQuote // ✅
    import extensionfunctions.singleQuote // ✅

    fun main() {
      "Single".singleQuote() eq "'Single'"
      "Double".doubleQuote() eq "\"Double\""
    }
  ```

- 확장 함수에서의 this

  ```kotlin
    fun String.strangeQuote() =
      this.singleQuote().singleQuote()

    fun String.tooManyQuotes() =
      doubleQuote().doubleQuote() // ✅

    fun main() {
      "Hi".strangeQuote() eq "''Hi''"
      "Hi".tooManyQuotes() eq "\"\"Hi\"\""
    }
  ```

  - 클래스 내부에서 this를 생략가능한 것과 마찬가지로 확장 함수에서도 생략 가능

- 확장 함수의 장점 : 간단한 코드 생성

  ```kotlin
    class Book(val title: String)

    fun Book.categorize(category: String) =
      """title: "$title", category: $category"""

    fun main() {
      Book("Dracula").categorize("Vampire") eq
        """title: "Dracula", category: Vampire"""
    }
  ```

  - 확장 함수는 수신 객체 타입의 프로퍼티가 public인 경우에만 접근이 가능하다.
  - `class Book(private val title: String)` : error 발생 (`Cannot access 'title': it is private in 'Book'`)

  - 정말 간결하니?? : 음...🤔

    > 확장함수를 사용하지 않는 같은 결과를 얻어내는 코드

    ```kotlin
      class Book(val title: String) {

          fun categorize(category: String) =
              """title: "$title", category: $category"""
      }

      fun main() {
          val book = Book("Dracula")
          book.categorize("Vampire") eq
                  """title: "Dracula", category: Vampire"""
      }
    ```

- 확장함수 유무 비교 (feat.chatGPT)

  - 확장함수를 사용하지 않은 것

    ```kotlin
    fun capitalizeFirstLetter(str: String): String {
        if (str.isEmpty()) return str
        return str.substring(0, 1).uppercase() + str.substring(1)
    }

    fun main() {
        val strings = listOf("hello", "world", "kotlin")
        val capitalizedStrings = strings.map { capitalizeFirstLetter(it) }

        println(capitalizedStrings) // [Hello, World, Kotlin]
    }
    ```

  - 확장함수를 사용한 것

    ```kotlin
    // String 타입에 대한 확장 함수 정의
    fun String.capitalizeFirstLetter(): String {
        if (this.isEmpty()) return this
        return this.substring(0, 1).uppercase() + this.substring(1)
    }

    fun main() {
        val strings = listOf("hello", "world", "kotlin")
        val capitalizedStrings = strings.map { it.capitalizeFirstLetter() }

        println(capitalizedStrings) // [Hello, World, Kotlin]
    }
    ```

    - 가독성 향상: 기존 클래스의 메서드를 호출하는 것처럼 코드가 자연스럽고 읽기 쉽다.
      - `it.capitalizeFirstLetter()`
    - 캡슐화: 확장 함수를 통해 특정 클래스에 관련된 동작을 해당 클래스 내부로 캡슐화 할 수 있다. 이는 코드의 응집도를 높이고, 다른 곳에서 재사용할 때 유용하다.
    - 코드 중복 감소: 여러 곳에서 동일한 작업을 수행해야 하는 경우, 확장 함수를 사용하면 코드 중복을 줄일 수 있다. 필요할 때마다 별도의 함수를 import하여 사용하는 대신, 확장 함수로 정의된 메서드를 호출하면 된다.
    - 기존 코드 수정 불필요: 확장 함수는 기존 클래스나 라이브러리를 수정하지 않고도 새로운 기능을 추가할 수 있게 한다. 이는 외부 라이브러리나 서드파티 코드를 사용할 때 특히 유용할 수 있다.
