# Atomic Kotlin 26 ~ 30

<details>
  <summary>Collection Hierarchy</summary>

![collection-hierarchy](../screenshots/collection-hierarchy.png)

- Red Box : ì—¬ê¸°ì„œ ë°°ìš¸ Collectionë“¤
- Blue Box : ì—¬ê¸°ì„  ë°°ìš°ì§€ì•Šì§€ë§Œ ë‹¤ì–‘í•œ Mapì˜ ì¢…ë¥˜ ([ê´€ë ¨ë§í¬](https://medium.com/depayse/kotlin-collections-2-map-hashmap-treemap-linkedhashmap-76195842f0c8))

</details>

## Atom26 ì§‘í•©(Set)

- Setì˜ ìƒì„± : ë¦¬ìŠ¤íŠ¸ì™€ ë§ˆì°¬ê°€ì§€ë¡œ ë‘ê°€ì§€ ìƒì„±í•¨ìˆ˜ ì œê³µ

  - `setOf()` â†’ ì½ê¸°ì „ìš© Set
  - `mutableSetOf()` â†’ ê°€ë³€ Set

- Set ì˜ íŠ¹ì§•

  ```kotlin
  fun main() {
    // 1
    val intSet = setOf(1, 1, 2, 3, 9, 9, 4)
    intSet eq setOf(1, 2, 3, 4, 9)

    // 2
    setOf(1, 2) eq setOf(2, 1)

    // 3
    (9 in intSet) eq true
    (99 in intSet) eq false

    intSet.contains(9) eq true
    intSet.contains(99) eq false

    // 4
    intSet.containsAll(setOf(1, 9, 2)) eq true

    // 5 : í•©ì§‘í•©
    intSet.union(setOf(3, 4, 5, 6)) eq
      setOf(1, 2, 3, 4, 5, 6, 9)

    // 6 : êµì§‘í•©
    intSet intersect setOf(0, 1, 2, 7, 8) eq
      setOf(1, 2)

    // 7 : ì°¨ì§‘í•©
    intSet subtract setOf(0, 1, 9, 10) eq
      setOf(2, 3, 4)
    intSet - setOf(0, 1, 9, 10) eq
      setOf(2, 3, 4)
  }

  ```

  - ì¤‘ë³µë˜ì§€ ì•ŠëŠ”ë‹¤.
  - ìˆœì„œê°€ ì—†ë‹¤
  - `in`, `contains()`ë¥¼ í†µí•´ì„œ ìš”ì†Œì¸ì§€ ì—¬ë¶€ë¥¼ í™•ì¸í•  ìˆ˜ ìˆë‹¤.
  - `containsAll()` ë¥¼ í†µí•´ì„œ Setë¼ë¦¬ì˜ í¬í•¨ì—¬ë¶€ë¥¼ í™•ì¸í•  ìˆ˜ ìˆë‹¤.
  - Setì˜ ì—°ì‚° ì§€ì›(ë°´ ë‹¤ì´ì–´ê·¸ë¨ ì—°ì‚°)
    - í•©ì§‘í•©(union, +), êµì§‘í•©(intersect), ì°¨ì§‘í•©(subtract, -)
      - ì í‘œê¸°ë²• : `set1.union(set2)`
      - ì¤‘ìœ„í‘œê¸°ë²• : `set1 union set2`, `set1 + set2`

- ì¤‘ë³µì œê±°ì—ì„œì˜ Set í™œìš©

  ```kotlin
    fun main() {
      val list = listOf(3, 3, 2, 1, 2)
      list.toSet() eq setOf(1, 2, 3)
      list.distinct() eq listOf(3, 2, 1)
      "abbcc".toSet() eq setOf('a', 'b', 'c')
    }
  ```

  - ë¦¬ìŠ¤íŠ¸ì—ì„œ ì§‘í•©ìœ¼ë¡œ ë³€ê²½í•˜ì—¬ ì¤‘ë³µì„ ì œê±°í•  ìˆ˜ ìˆë‹¤.
    - `toSet()` ì´ìš©
  - `distinct()` ë¥¼ ì´ìš©í•˜ì—¬ ì¤‘ë³µì„ ì œê±°í•  ìˆ˜ ìˆë‹¤.
    - Array, Listì—ì„œ ì‚¬ìš©í•˜ì—¬ ì¤‘ë³µì„ ì œê±°í•œ Array ë‚˜ Listë¥¼ ë°˜í™˜í•œë‹¤. ë‹¨, ìˆœì„œëŠ” ìœ ì§€ëœë‹¤.
    - Setì—ì„œë„ distinct() ë©¤ë²„í•¨ìˆ˜ ì¡´ì¬í•˜ì§€ë§Œ, Setì˜ íŠ¹ì„±ìƒ ì˜ë¯¸ì—†ëŠ” ë©¤ë²„í•¨ìˆ˜ì´ë‹¤. ë‹¨ì§€ Collection ì¸í„°í˜ì´ìŠ¤ì—ì„œ ìƒì†ë˜ì–´ì„œ ìˆëŠ” ê²ƒì´ë‹¤.
  - `ë¬¸ìì—´.toSet()` ì„ í†µí•´ì„œë„ ì¤‘ë³µì„ ì œê±°í•  ìˆ˜ ìˆë‹¤.

  - ìœ„ì˜ ë‚´ìš©ì„ í™œìš©í•œ ë¬¸ìì—´ì˜ ì¤‘ë³µì„ ì—†ì• ëŠ” ë˜ë‹¤ë¥¸ ë°©ë²•
    ```kotlin
      val b = "helloworld".toList()
      val c = b.distinct()
      println(c)
    ```
    > ë‹¹ì—°í•˜ê²Œë„ íƒ€ì…ì€ ë‹¤ë¦„!

- MutableSet

  - ë¦¬ìŠ¤íŠ¸ì™€ ë§ˆì°¬ê°€ì§€ë¡œ +/- ì—°ì‚°ì„ í†µí•´ì„œ ì›ì†Œë¥¼ ì¶”ê°€ ì‚­ì œê°€ ê°€ëŠ¥í•˜ë‹¤.

    ```kotlin
      fun main() {
        val mutableSet = mutableSetOf<Int>()
        mutableSet += 42
        mutableSet += 42
        mutableSet eq setOf(42)
        mutableSet -= 42
        mutableSet eq setOf<Int>()
      }
    ```

<details>
  <summary>ì°¸ê³ </summary>

```kotlin
fun main() {
    val list = mutableListOf(1,2,3,4) // o.k
    var list = mutableListOf(1,2,3,4) // o.k
    val list = listOf(1,2,3,4) // val not reassign
    var list = listOf(1,2,3,4) // o.k
    list += 5
    println(list)
    list -= 1
    println(list)
}
```

> [ì‹¤í–‰ë§í¬](https://pl.kotl.in/ij3t9Mgxs)

í˜„ìƒì ìœ¼ë¡œë§Œ ë”°ì§€ë©´, valì— í• ë‹¹í•˜ê³  ì½ê¸°ì „ìš© ìƒì„±í•¨ìˆ˜ì¸ listOfë¡œ ìƒì„±í•˜ëŠ” ê²½ìš°ì—ë§Œ ì—°ì‚°ì´ ë¶ˆê°€ëŠ¥í•˜ë‹¤.

</details>

## Atom27 ë§µ

> ë§µì€ í‚¤ì™€ ê°’ì„ ì—°ê²°ì‹œì¼œì£¼ê¸° ë•Œë¬¸ì— ì´ë¥¼ `ì—°ê´€ ë°°ì—´(associative array)` ë¼ê³  ë¶€ë¥´ê¸°ë„ í•œë‹¤.

- Mapì˜ ìƒì„±

  - í‚¤-ê°’ ìŒì„ mapOf()ì— ì „ë‹¬
  - í‚¤-ê°’ ì „ë‹¬ í˜•ì‹ : `í‚¤ to ê°’`

  ```kotlin
  fun main() {
      val constants = mapOf(
      "Pi" to 3.141,
      "e" to 2.718,
      "phi" to 1.618
    )
    constants eq
      "{Pi=3.141, e=2.718, phi=1.618}"
  }
  ```

- Mapì˜ íŠ¹ì§•

  ```kotlin
  fun main() {

  // 1) ì ‘ê·¼
  constants["e"] eq 2.718
  constants.keys eq setOf("Pi", "e", "phi")
  constants.values eq "[3.141, 2.718, 1.618]"

  // 2) ë°˜ë³µ1
  var s = ""
  for (entry in constants) {
    s += "${entry.key}=${entry.value}, "
  }
  s eq "Pi=3.141, e=2.718, phi=1.618,"


  // 3) ë°˜ë³µ2
  s = ""
  for ((key, value) in constants)
    s += "$key=$value, "
  s eq "Pi=3.141, e=2.718, phi=1.618,"
  }
  ```

  - ì ‘ê·¼

    - `map[íŠ¹ì •í‚¤]` : íŠ¹ì • í‚¤ë¥¼ ê°€ì§„ ê°’ì„ ì–»ì„ ìˆ˜ ìˆë‹¤.
    - `map.keys` : mapì˜ ëª¨ë“  í‚¤ë¥¼ ê°€ì ¸ì˜¨ë‹¤.

      â†’ í•˜ë‚˜ì˜ mapì•ˆì—ì„œ í‚¤ëŠ” ìœ ì¼í•˜ê¸° ë•Œë¬¸ì— ê²°êµ­ Setì´ ìƒì„±ëœë‹¤. ì‹¤ì œë¡œ ë¦¬í„´ íƒ€ì…ë„ Setì´ë‹¤.

      ```kotlin
      public val keys: Set<K>
      ```

    - `map.values` : mapì˜ ëª¨ë“  ê°’ì„ ê°€ì ¸ì˜¨ë‹¤.

      ```kotlin
      public val values: Collection<V>
      ```

  - ë°˜ë³µ(Iterate)

    - `for (entry in constants)` : for loop
      - `entry.key` : í‚¤
      - `entry.value` : ê°’
    - `for ((key, value) in constants)` : unpacking for loop
      - key, value ë¡œ ì§ì ‘ ì ‘ê·¼

- MutableMap

  ```kotlin
    fun main() {
      val m =
        mutableMapOf(5 to "five", 6 to "six")
      m[5] eq "five"

      m[5] = "5ive"
      m[5] eq "5ive"

      m += 4 to "four"
      m eq mapOf(5 to "5ive",
        4 to "four", 6 to "six")
    }
  ```

  - `m[5] = "5ive"` : ê¸°ì¡´ 5 ë¥¼ ë³€ê²½í•  ìˆ˜ ìˆë‹¤.
  - `m += 4 to "four"` : ëª…ì‹œì ìœ¼ë¡œ í‚¤ì™€ ê°’ì„ ì¶”ê°€í•  ìˆ˜ ìˆë‹¤.
  - mapof(), mutableMapOf()ëŠ” Mapì— ì „ë‹¬ëœ ìˆœì„œë¥¼ ìœ ì§€í•´ì£¼ì§€ë§Œ, ë‹¤ë¥¸ Map(ìƒë‹¨ì˜ hierarchy ì°¸ê³ )ì—ì„œëŠ” ìˆœì„œê°€ ë³´ì¥ë˜ì§€ ì•Šì„ ìˆ˜ ìˆë‹¤.

- ReadOnlyMap

  ```kotlin
    fun main() {
      val m = mapOf(5 to "five", 6 to "six")
      m[5] eq "five"

      // m[5] = "5ive" // ë¶ˆê°€ëŠ¥
      // m += (4 to "four") // ë¶ˆê°€ëŠ¥
      m + (4 to "four") // mì„ ë³€ê²½í•  ìˆ˜ ì—†ìŒ
      m eq mapOf(5 to "five", 6 to "six")

      val m2 = m + (4 to "four")
      m2 eq mapOf(
        5 to "five", 6 to "six", 4 to "four")
  }
  ```

  - ì½ê¸°ì „ìš© Map : ìˆ˜ì •, ì¶”ê°€ ë¶ˆê°€ëŠ¥
  - ì½ê¸°ì „ìš© Mapì—ì„œ í‚¤-ê°’ì„ ì¶”ê°€í•˜ëŠ” ë°©ë²•ì€ ìƒˆë¡œìš´ Mapì„ ìƒì„±í•´ì•¼í•œë‹¤.

- ë§µì˜ ê¸°ë³¸ê°’ ì„¤ì •

  ```kotlin
  fun main() {
    val map = mapOf('a' to "attempt")
    map['b'] eq null

    capture {
      map.getValue('b')
    } eq "NoSuchElementException: " +
      "Key b is missing in the map."

    map.getOrDefault('a', "??") eq "attempt"
    map.getOrDefault('b', "??") eq "??"
  }
  ```

  - Mapì—ì„œ íŠ¹ì • í‚¤ë¡œ ì ‘ê·¼í• ë•Œ, í‚¤ì— ëŒ€í•œ ê°’ì´ ì—†ìœ¼ë©´ nullì„ ë°˜í™˜í•œë‹¤.
  - `getValue()` ë©¤ë²„í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ì—¬ ì ‘ê·¼í•˜ë©´, ê°’ì´ ì—†ìœ¼ë©´ `NoSuchElementException` ë¥¼ ë°˜í™˜í•œë‹¤.
  - ê°€ì¥ ì¢‹ì€ ë°©ë²•ì€ `getOrDefault(key, defaultValue)` ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ë‹¤. í‚¤ë¡œ ì ‘ê·¼í•  ë•Œ, ê°’ì´ ì—†ìœ¼ë©´, ì„¤ì •ëœ ê¸°ë³¸ê°’ì„ ë°˜í™˜í•œë‹¤.

- í´ë˜ìŠ¤ ì¸ìŠ¤í„´ìŠ¤ë¥¼ Mapì— ì €ì¥í•˜ëŠ” ë°©ë²•

  ```kotlin
  class Contact(
    val name: String,
    val phone: String
  ) {
    override fun toString(): String {
      return "Contact('$name', '$phone')"
    }
  }

  fun main() {
    val miffy = Contact("Miffy", "1-234-567890")
    val cleo = Contact("Cleo", "098-765-4321")
    val contacts = mapOf(
      miffy.phone to miffy,
      cleo.phone to cleo)
    contacts["1-234-567890"] eq miffy
    contacts["1-111-111111"] eq null
  }
  ```

  - `miffy` ì™€ `cleo` ì¸ìŠ¤í„´ìŠ¤ ìƒì„±
  - ê° ì „í™”ë²ˆí˜¸ì— ë§ëŠ” ì¸ìŠ¤í„´ìŠ¤ë¥¼ ì €ì¥í•  ìˆ˜ ìˆë‹¤.(ì¸ìŠ¤í„´ìŠ¤ ë§µí•‘)

    â†’ ì¸ìŠ¤í„´ìŠ¤ë¥¼ í‚¤ë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ”ë°, ì´ ë°©ë²•ì€ ë’¤ì—ì„œ í•™ìŠµ

## Atom28 í”„ë¡œí¼í‹° ì ‘ê·¼ì

> í´ë˜ìŠ¤ ë‚´ë¶€ì— ì„ ì–¸ëœ í”„ë¡œí¼í‹°ì— ëŒ€í•œ `getter`ì™€ `setter` ë¥¼ ì–´ë–»ê²Œ ì‚¬ìš©í•˜ëŠ”ì§€ì— ëŒ€í•´ì„œ ì•Œì•„ë³¸ë‹¤.

- í”„ë¡œí¼í‹° ì ‘ê·¼

  ```kotlin
    class Data(var i: Int)

    fun main() {
      val data = Data(10)
      data.i eq 10  // get
      data.i = 20   // set
    }
  ```

  - ì¸ìŠ¤í„´ìŠ¤ ë‚´ë¶€ì˜ í”„ë¡œí¼í‹°ë¥¼ í†µí•´ì„œ `get`ê³¼ `set`ì„ í•  ìˆ˜ ìˆë‹¤.

- í”„ë¡œí¼í‹° ì ‘ê·¼ ì»¤ìŠ¤í„°ë§ˆì´ì§•

  ```kotlin
  class Default {
    var i: Int = 0
      get() {
        trace("get()")
        return field
      }
      set(value) {
        trace("set($value)")
        field = value
      }
  }

  fun main() {
    val d = Default()
    d.i = 2
    trace(d.i)
    trace eq """
      set(2)
      get()
      2
    """
  }
  ```

  - í´ë˜ìŠ¤ ë‚´ë¶€ì—ì„œ í”„ë¡œí¼í‹° ì •ì˜ ì´í›„ì— `getter`ì™€ `setter`ë¥¼ ì •ì˜í•  ìˆ˜ ìˆë‹¤.
  - getterì™€ setterë¥¼ ì •ì˜í•˜ëŠ” ìˆœì„œëŠ” ì¤‘ìš”í•˜ì§€ ì•Šë‹¤.
  - getterì™€ setter ë‚´ë¶€ì—ë§Œ ì¡´ì¬í•˜ëŠ” `field` ë¼ëŠ” ì´ë¦„ì„ ì‚¬ìš©í•´ ì €ì¥ëœ ê°’ì— ì§ì ‘ ì ‘ê·¼ ê°€ëŠ¥í•˜ë‹¤.
  - getterì™€ setter ì•ˆì—ì„œ ì»¤ìŠ¤í„°ë§ˆì´ì§•ì´ ê°€ëŠ¥í•˜ë‹¤. ìœ„ì—ì„œëŠ” ê°’ì„ ì½ê³  ì“°ëŠ” ê³¼ì •ì—ì„œ ì¶”ê°€ ì •ë³´ê°€ ì¶œë ¥ë  ìˆ˜ ìˆë„ë¡ ë§Œë“  ê²ƒì´ë‹¤.

- private

  ```kotlin
  class Counter {
    var value: Int = 0 // âœ…
      private set      // âœ…
    fun inc() = value++
  }

  fun main() {
    val counter = Counter()

    // counter.value++

    repeat(10) {
      counter.inc()
    }
    counter.value eq 10
  }
  ```

  - valueì— ëŒ€í•œ ì ‘ê·¼ì ëª¨ë‘ private ì„¤ì • : `private var value: Int = 0`
  - ìœ„ ì½”ë“œëŠ” `getterëŠ” public`ì´ê³  `setterëŠ” private` ìœ¼ë¡œ ì„¤ì •í•œ ê²ƒìœ¼ë¡œ ë“¤ì—¬ì“°ê¸° í˜•ì‹ì„ ë§ì¶°ì•¼í•˜ëŠ” ê²ƒìœ¼ë¡œ ë³´ì¸ë‹¤.(ì¸í…”ë¦¬ì œì´ì—ì„œ ìë™ìœ¼ë¡œ ë“¤ì—¬ì“°ê¸°ë¨)
  - [TEST] `counter.value++` â†’ error : Cannot assign to 'value': the setter is private in 'Counter'

- fieldë¥¼ ì‚¬ìš©í•˜ì§€ ì•ŠëŠ” ì ‘ê·¼ì

  ```kotlin
  class Hamster(val name: String)

  class Cage(private val maxCapacity: Int) {
    private val hamsters =
      mutableListOf<Hamster>()

    val capacity: Int
      get() = maxCapacity - hamsters.size
    val full: Boolean
      get() = hamsters.size == maxCapacity

    fun put(hamster: Hamster): Boolean =
      if (full)
        false
      else {
        hamsters += hamster
        true
      }
    fun take(): Hamster =
      hamsters.removeAt(0)
  }

  fun main() {
    val cage = Cage(2)
    cage.full eq false
    cage.capacity eq 2
    cage.put(Hamster("Alice")) eq true
    cage.put(Hamster("Bob")) eq true
    cage.full eq true
    cage.capacity eq 0
    cage.put(Hamster("Charlie")) eq false
    cage.take()
    cage.capacity eq 1
  }
  ```

  - `full` ê³¼ `capacity` ëŠ” ë‚´ë¶€ í”„ë¡œí¼í‹° ê°’ì„ ì´ìš©í•´ì„œ getterë¥¼ ì •ì˜í•˜ê³  ìˆë‹¤.

- ë¦¬íŒ©í† ë§

  ```kotlin
  class Cage2(private val maxCapacity: Int) {
    private val hamsters =
      mutableListOf<Hamster>()
    fun capacity(): Int =
      maxCapacity - hamsters.size
    fun isFull(): Boolean =
      hamsters.size == maxCapacity
  }
  ```

  - ìœ„ì—ì„œ `full` ê³¼ `capacity` ë¥¼ í”„ë¡œí¼í‹°ë¥¼ ë©¤ë²„í•¨ìˆ˜ë¡œ ë³€ê²½í•  ìˆ˜ ìˆë‹¤.
  - í”„ë¡œí¼í‹° vs ë©¤ë²„í•¨ìˆ˜??
    - ì½”í‹€ë¦° ìŠ¤íƒ€ì¼ ê°€ì´ë“œì—ì„œëŠ” ê³„ì‚°ë¹„ìš©ì´ ë§ì§€ì•Šê³ , ê°ì²´ìƒíƒœë¥¼ ë³€ê²½í•˜ì§€ ì•ŠëŠ” í•œ ë©¤ë²„í•¨ìˆ˜ë³´ë‹¤ëŠ” **í”„ë¡œí¼í‹°**ë¥¼ ì‚¬ìš©í•  ê²ƒì„ ì¶”ì²œ

## Atom29 : 2ë¶€ ìš”ì•½

### íŒ¨í‚¤ì§€ì™€ í…ŒìŠ¤íŠ¸

```kotlin
  package com.yoururl.libraryname

  fun f() = "result"
```

- `package` : ì¬ì‚¬ìš©ì´ ê°€ëŠ¥í•œ ë¼ì´ë¸ŒëŸ¬ë¦¬ ì»´í¼ë„ŒíŠ¸ë¥¼ ì›í•˜ëŠ” ë§Œí¼ ë¬¶ì„ ìˆ˜ ìˆë‹¤.

  - ìœ„ ì½”ë“œì—ì„œëŠ” 1ê°œì˜ ì»´í¼ë„ŒíŠ¸(`fun f`)ë§Œì„ packageì—ì„œ êº¼ë‚´ì„œ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.

- íŒ¨í‚¤ì§€ ì´ë¦„ì€ ê´€ìŠµì ìœ¼ë¡œ ë„ë©”ì¸ì˜ ì´ë¦„ì„ ì—­ìˆœìœ¼ë¡œ í•˜ì—¬ ì‚¬ìš©í•œë‹¤.

  - `yoururl.com` â†’ `com.yoururl`

- ì½”í‹€ë¦°ì—ì„œì˜ íŒ¨í‚¤ì§€ ì´ë¦„ì€ íŒ¨í‚¤ì§€ì˜ íŒŒì¼ì‹œìŠ¤í…œì—ì„œì˜ ìœ„ì¹˜ì™€ ë¬´ê´€í•˜ë‹¤.

  - ìë°”ì—ì„œëŠ” íŒŒì¼ì˜ ìœ„ì¹˜ì™€ íŒ¨í‚¤ì§€ëª…ì´ ì—°ê²°ë˜ì–´ìˆë‹¤. â†’ `com/yoururl/libraryname`ì— ìœ„ì¹˜í•˜ê²Œëœë‹¤.

- `import com.yoururl.libraryname.*` : \* ë¥¼ í†µí•´ì„œ ë¼ì´ë¸ŒëŸ¬ë¦¬ì— ì†í•œ ëª¨ë“  ì»´í¼ë„ŒíŠ¸ë¥¼ ì„í¬íŠ¸ í•  ìˆ˜ ìˆë‹¤.

  - êµ¬ì²´ì ì¸ ì´ë¦„ì„ í†µí•´ì„œ íŠ¹ì • ì»´í¼ë„ŒíŠ¸ë§Œ ì„í¬íŠ¸í•  ìˆ˜ ë„ ìˆë‹¤.

- testëŠ” ìƒëµ!!

### ê°ì²´ëŠ” ëª¨ë“  ê³³ì— ì¡´ì¬í•œë‹¤

```kotlin
fun main() {
  val lst = listOf(19.2, 88.3, 22.1)
  lst[1] eq 88.3
  lst.reversed() eq listOf(22.1, 88.3, 19.2)
  lst.sorted() eq listOf(19.2, 22.1, 88.3)
  lst.sum() eq 129.6
}
```

- ì½”í‹€ë¦°ì€ í•˜ì´ë¸Œë¦¬ë“œ ê°ì²´-í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë° ì–¸ì–´ì´ë‹¤.

  - ê°ì²´ ì§€í–¥ê³¼ í•¨ìˆ˜í˜• ì§€í–¥ì„ ëª¨ë‘ ì§€ì›

- ê°ì²´ ì¤‘ì— ê°€ì¥ ìœ ìš©í•œ ìœ í˜• : ì»¨í…Œì´ë„ˆ(`ì½œë ‰ì…˜`)

  - ì½œë ‰ì…˜ : ë‹¤ë¥¸ ê°ì²´ë¥¼ ë‹´ëŠ” ê°ì²´ â†’ Listê°€ ê°€ì¥ ë§ì´ ì‚¬ìš©ëœë‹¤.
  - `reversed()`, `sorted()` : ë¦¬ìŠ¤íŠ¸ ë‚´ë¶€ì˜ ë³€í™”ì—†ì´ ë³€ê²½ëœ ìƒˆë¡œìš´ ë¦¬ìŠ¤íŠ¸ë¥¼ ë°˜í™˜í•œë‹¤.
    - ì´ëŸ° ì‹ìœ¼ë¡œ ì›ë³¸ ê°ì²´ë¥¼ ë³€ê²½í•˜ì§€ ì•ŠëŠ” ì ‘ê·¼ ë°©ì‹ì„ ì½”í‹€ë¦° ë¼ì´ë¸ŒëŸ¬ë¦¬ì—ì„œ ì¼ê´€ë˜ê²Œ ì ‘í•  ìˆ˜ ìˆì„ ê²ƒì´ê³ , ìš°ë¦¬ëŠ” ì´ëŸ¬í•œ íŒ¨í„´ì— ë§ê²Œ ì½”ë”©ì„ í•´ì•¼í•œë‹¤.

### í´ë˜ìŠ¤ ë§Œë“¤ê¸°

```kotlin
class NoBody

class SomeBody {
  val name = "Janet Doe"
}

class EveryBody {
  val all = listOf(SomeBody(),
    SomeBody(), SomeBody())
}

fun main() {
  val nb = NoBody()
  val sb = SomeBody()
  val eb = EveryBody()
}

```

- í´ë˜ìŠ¤ ìƒì„±
  - class í‚¤ì›Œë“œ, class ì´ë¦„, ë³¸ë¬¸ ì´ë ‡ê²Œ ì •ì˜ëœë‹¤. ì´ ë•Œ ë³¸ë¬¸ì€ ì—†ì„ìˆ˜ë„ ìˆë‹¤.
  - í´ë˜ìŠ¤ ë‚´ë¶€ì—ëŠ” í”„ë¡œí¼í‹° ì •ì˜ì™€ ë©¤ë²„í•¨ìˆ˜ ì •ì˜ê°€ ë“¤ì–´ê°„ë‹¤.

```kotlin
class Temperature {
  var current = 0.0
  var scale = "f"
  fun setFahrenheit(now: Double) {
    current = now
    scale = "f"
  }
  fun setCelsius(now: Double) {
    current = now
    scale = "c"
  }
  fun getFahrenheit(): Double =
    if (scale == "f")
      current
    else
      current * 9.0 / 5.0 + 32.0
  fun getCelsius(): Double =
    if (scale == "c")
      current
    else
      (current - 32.0) * 5.0 / 9.0
}

fun main() {
  val temp = Temperature()   // [1]
  temp.setFahrenheit(98.6)
  temp.getFahrenheit() eq 98.6
  temp.getCelsius() eq 37.0
  temp.setCelsius(100.0)
  temp.getFahrenheit() eq 212.0
}
```

- ì¸ìŠ¤í„´ìŠ¤ ìƒì„±ì‹œ new ì‚¬ìš©í•˜ì§€ ì•Šê³ , `í´ë˜ìŠ¤ì´ë¦„([ì¸ì])` í˜•íƒœë¡œ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ìƒì„±í•  ìˆ˜ ìˆë‹¤.
- ë©¤ë²„í•¨ìˆ˜ëŠ” í´ë˜ìŠ¤ ë‚´ë¶€ì—ì„œ ì •ì˜ëœë‹¤ëŠ” ì ì„ ì œì™¸í•˜ê³ ëŠ” í´ë˜ìŠ¤ ì™¸ë¶€ì—ì„œ ì •ì˜ëœ í•¨ìˆ˜ì™€ ë™ì¼í•˜ë‹¤. ë˜í•œ ê°™ì€ í´ë˜ìŠ¤ ë‚´ë¶€ì˜ í”„ë¡œí¼í‹°(ë©¤ë²„)ì— ì œí•œì—†ì´ ì ‘ê·¼ì´ ê°€ëŠ¥í•˜ë‹¤.

```kotlin
class Cell {
  var entry = ' '
  fun setValue(e: Char): String =   // âœ…
    if (entry == ' ' &&
      (e == 'X' || e == 'O')) {
      entry = e
      "Successful move"
    } else
      "Invalid move"
}

class Grid {
  val cells = listOf(               // âœ…
    listOf(Cell(), Cell(), Cell()),
    listOf(Cell(), Cell(), Cell()),
    listOf(Cell(), Cell(), Cell())
  )
  fun play(e: Char, x: Int, y: Int): String =
    if (x !in 0..2 || y !in 0..2)   // âœ…
      "Invalid move"
    else
      cells[x][y].setValue(e)       // âœ…
}

fun main() {
  val grid = Grid()
  grid.play('X', 1, 1) eq "Successful move"
  grid.play('X', 1, 1) eq "Invalid move"
  grid.play('O', 1, 3) eq "Invalid move"
}
```

- ìœ„ ì½”ë“œëŠ” í‹±íƒí† ì˜ ê¸°ë³¸ì ì¸ í´ë˜ìŠ¤ ì½”ë“œì´ë‹¤.
- í‹±íƒí†  ë³´ë“œì˜ ê·¸ë¦¬ë“œì™€ ê·¸ë¦¬ë“œ ì•ˆì˜ ì…€ì„ ê°ê° í´ë˜ìŠ¤ë¡œ êµ¬í˜„í•˜ì—¬ ê·¸ë¦¬ë“œ ìƒì„±ì‹œ ì´ì¤‘ë°°ì—´(ì´ì¤‘ë¦¬ìŠ¤íŠ¸)ê°€ ìƒì„±ëœë‹¤.

- Grid í´ë˜ìŠ¤ ë©¤ë²„í•¨ìˆ˜ play ì•ˆì—ì„œ ê° Cell í´ë˜ìŠ¤ì˜ ë©¤ë²„í•¨ìˆ˜ì¸ setValueê°€ í˜¸ì¶œë˜ê³ , ê·¸ ë©¤ë²„í•¨ìˆ˜ ì•ˆì—ì„œ ì¡°ê±´ë¬¸ì— ì˜í•´ ì²´í¬ëœ ë’¤ì— ë¬¸ìì—´ ê²°ê³¼ë¥¼ ë°˜í™˜í•œë‹¤.

- `if(x !in 0..2)` : x ê°€ 0~2ì— í¬í•¨ë˜ì§€ ì•Šìœ¼ë©´

### ìƒì„±ì

```kotlin
class Badger(id: String, years: Int) {
  val name = id
  val age = years
  override fun toString(): String {
    return "Badger: $name, age: $age"
  }
}

class Snake(
  var type: String,
  var length: Double
) {
  override fun toString(): String {
    return "Snake: $type, length: $length"
  }
}

class Moose(
  val age: Int,
  val height: Double
) {
  override fun toString(): String {
    return "Moose, age: $age, height: $height"
  }
}

fun main() {
  Badger("Bob", 11) eq "Badger: Bob, age: 11"
  Snake("Garden", 2.4) eq
    "Snake: Garden, length: 2.4"
  Moose(16, 7.2) eq
    "Moose, age: 16, height: 7.2"
}

```

- ìƒì„±ì ì •ë³´ë¥¼ ì „ë‹¬í•  ë•Œ, íŒŒë¼ë¯¸í„° ëª©ë¡ì„ ìƒì„±ì ì´ë¦„ ë’¤ì— `( )`ë¥¼ í†µí•´ì„œ ì „ë‹¬í•œë‹¤.

- Badger í´ë˜ìŠ¤

  - ìƒì„±ì íŒŒë¼ë¯¸í„°ë¥¼ í´ë˜ìŠ¤ ë³¸ë¬¸ì—ì„œë§Œ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤. ë‹¤ë¥¸ ê³³ì—ì„œ ì°¸ì¡°í•˜ê³  ì‹¶ë‹¤ë©´, ë³¸ë¬¸ì—ì„œ í”„ë¡œí¼í‹°ë¡œ í• ë‹¹ í›„ ê°€ëŠ¥í•˜ë‹¤.

    ```kotlin
      class Badger(id: String, years: Int) {
        fun change() {
            var name = id  // ğŸ”¥ error : Unresolved reference: id
        }

      }
    ```

- Snake í´ë˜ìŠ¤ / Moose í´ë˜ìŠ¤

  - ìƒì„±ì íŒŒë¼ë¯¸í„°ì— `var`, `val` ë¡œ ì •ì˜í•˜ë©´ íŒŒë¼ë¯¸í„°ê°€ ë°”ë¡œ í”„ë¡œí¼í‹°ë¡œ ë³€ê²½ë˜ì–´ í´ë˜ìŠ¤ ë‚´ë¶€ ì–´ë””ì„œë“  ì°¸ì¡°ê°€ ê°€ëŠ¥í•˜ë‹¤.
  - val ëŠ” ë³€ê²½ì´ ë¶ˆê°€ëŠ¥, varëŠ” ë³€ê²½ì´ ê°€ëŠ¥

- override
  - ì´ë¯¸ ë‹¤ë¥¸ ê³³ì—ì„œ ì •ì˜ë˜ì–´ìˆëŠ” ë©¤ë²„í•¨ìˆ˜ë¥¼ ì¬ì •ì˜í•˜ì—¬ ì‚¬ìš©í•˜ê³  ì‹¶ì„ë•Œ ì½”í‹€ë¦°ì—ì„œëŠ” ëª…ì‹œì ìœ¼ë¡œ override ë¼ëŠ” í‚¤ì›Œë“œë¥¼ ìš”êµ¬í•œë‹¤. â†’ í•¨ìˆ˜ ì¬ì •ì˜ ëª©ì ê³¼ ì˜¤ë¥˜ ë°©ì§€ì˜ ì¥ì  ì¡´ì¬

### ê°€ì‹œì„± ì œí•œí•˜ê¸°

- ì½”í‹€ë¦°ì—ì„œ ë‹¤ë¥¸ ì–¸ì–´ì™€ ë§ˆì°¬ê°€ì§€ë¡œ ì ‘ê·¼ ë³€ê²½ìë¥¼ ì œê³µí•œë‹¤. ì´ë¥¼ ì´ìš©í•˜ë©´ í´ë¼ì´ì–¸íŠ¸ë‹¨ì— ê³µê°œí•  ë‚´ìš©ì„ ì œì–´í•  ìˆ˜ ìˆë‹¤.
- ì ‘ê·¼ ë³€ê²½ì ì¢…ë¥˜ : private, public, protected, internal

> ì˜ˆì‹œ1

```kotlin
private var count = 0                   // [1]

private class Box(val dimension: Int) { // [2]
  fun volume() =
    dimension * dimension * dimension
  override fun toString() =
    "Box volume: ${volume()}"
}

private fun countBox(box: Box) {        // [3]
  trace("$box")
  count++                               // âœ…
}

fun countBoxes() {
  countBox(Box(4))                      // âœ…
  countBox(Box(5))
}
```

- [1]/[2]/[3] : ëª¨ë‘ privateì´ê¸°ë•Œë¬¸ì— íŒŒì¼ ë‚´ë¶€ì—ì„œëŠ” ì ‘ê·¼ì´ ê°€ëŠ¥í•˜ì§€ë§Œ, íŒŒì¼ ì™¸ë¶€ì—ì„œëŠ” ì ‘ê·¼ì´ ë¶ˆê°€ëŠ¥í•˜ë‹¤.

> ì˜ˆì‹œ2

```kotlin
class JetPack(
  private var fuel: Double   // [1]
) {
  private var warning = false
  private fun burn() =       // [2]
    if (fuel - 1 <= 0) {
      fuel = 0.0
      warning = true
    } else
      fuel -= 1
  public fun fly() = burn()  // [3]

  fun check() =              // [4]
    if (warning)             // [5]
      "Warning"
    else
      "OK"
}

fun main() {
  val jetPack = JetPack(3.0)
  while (jetPack.check() != "Warning") {
    jetPack.check() eq "OK"
    jetPack.fly()
  }
  jetPack.check() eq "Warning"
}
```

- [1]/[2] : private ì´ê¸°ë•Œë¬¸ì— í´ë˜ìŠ¤ ë‚´ë¶€ì—ì„œë§Œ ì ‘ê·¼ ê°€ëŠ¥
- [3]/[4] : public ì´ê¸°ë•Œë¬¸ì— í´ë˜ìŠ¤ ì™¸ë¶€ì—ì„œ ì ‘ê·¼ ê°€ëŠ¥

### ì˜ˆì™¸

- ì˜ˆì™¸ê°€ ë˜ì ¸ì§€ë©´ í˜„ì¬ ì‹¤í–‰ ê²½ë¡œê°€ ì¤‘ë‹¨ë˜ê³ , ì˜ˆì™¸ëŠ” ìƒìœ„ ë¬¸ë§¥ìœ¼ë¡œ ì „ë‹¬ëœë‹¤. ì˜ˆì™¸ë¥¼ ì¡ì•„ë‚´ì§€ ì•Šìœ¼ë©´ í”„ë¡œê·¸ë¨ì´ ì¤‘ë‹¨ë˜ë©´ì„œ ìì„¸í•œ ì •ë³´ë¥¼ í¬í•¨í•˜ëŠ” ìŠ¤íƒ íŠ¸ë ˆì´ìŠ¤ê°€ í‘œì‹œëœë‹¤.
- [ì±…ì— ëŒ€í•œ ë‚´ìš©]

  - `capture()` : ì˜ˆì™¸ë¥¼ í™•ì¸ì„ ìœ„í•´ì„œ ì£¼ì„ì„ í•´ì œë¥¼ ë°˜ë³µí•˜ëŠ” ìˆ˜ê³ ë¥¼ ëœê¸°ìœ„í•´ì„œ, captureí•¨ìˆ˜ë¥¼ ì œê³µí•œë‹¤. í•´ë‹¹ í•¨ìˆ˜ì˜ ì—­í• ì€ ì˜ˆì™¸ ë°œìƒí•˜ëŠ” ëª¨ìŠµì„ ìº¡ì³í•´ì„œ ë°˜í™˜í•˜ê³  ë¹Œë“œì‹œìŠ¤í…œì´ ì˜ˆì™¸ ì¶œë ¥ë¥¼ ê²€ì‚¬í•  ìˆ˜ ìˆë„ë¡ êµ¬í˜„ë˜ì—ˆë‹¤.

- `throw ì˜ˆì™¸í´ë˜ìŠ¤ì´ë¦„(ì¸ì)`

  ```kotlin
  class Roots(
    val root1: Double,
    val root2: Double
  )

  fun quadraticZeroes(
    a: Double,
    b: Double,
    c: Double
  ): Roots {
    if (a == 0.0)
      throw IllegalArgumentException(
        "a is zero")
    val underRadical = b * b - 4 * a * c
    if (underRadical < 0)
      throw IllegalArgumentException(
        "Negative underRadical: $underRadical")
    val squareRoot = sqrt(underRadical)
    val root1 = (-b - squareRoot) / (2 * a)
    val root2 = (-b + squareRoot) / (2 * a)
    return Roots(root1, root2)
  }

  fun main() {
    capture {
      quadraticZeroes(0.0, 4.0, 5.0)
    } eq "IllegalArgumentException: " +
      "a is zero"
    capture {
      quadraticZeroes(3.0, 4.0, 5.0)
    } eq "IllegalArgumentException: " +
      "Negative underRadical: -44.0"
    val roots = quadraticZeroes(1.0, 2.0, -8.0)
    roots.root1 eq -4.0
    roots.root2 eq 2.0
  }
  ```

  - ê·¼ì˜ ê³µì‹ 2ê°€ì§€ ì˜ˆì™¸

    - aê°€ 0ì´ ë  ìˆ˜ ì—†ë‹¤.
      - `throw IllegalArgumentException("a is zero")`
    - b^2 - 4ac ëŠ” ìŒìˆ˜ê°€ ë  ìˆ˜ ì—†ë‹¤ â†’ b^2 - 4ac >= 0
      - `throw IllegalArgumentException("Negative underRadical: $underRadical")`

  - IllegalArgumentException : í‘œì¤€ì˜ˆì™¸

  - ì˜ˆì™¸ íƒ€ì…ì˜ ìœ„ê³„

    ```
    Throwable
    â”œâ”€â”€ Exception
    â”‚   â”œâ”€â”€ RuntimeException
    â”‚   â”‚   â”œâ”€â”€ NullPointerException
    â”‚   â”‚   â”œâ”€â”€ IndexOutOfBoundsException
    â”‚   â”‚   â”œâ”€â”€ IllegalArgumentException  âœ…
    â”‚   â”‚   â””â”€â”€ ê¸°íƒ€ RuntimeExceptionì˜ ì„œë¸Œí´ë˜ìŠ¤ë“¤
    â”‚   â””â”€â”€ IOException
    â”‚       â”œâ”€â”€ FileNotFoundException
    â”‚       â””â”€â”€ ê¸°íƒ€ IOExceptionì˜ ì„œë¸Œí´ë˜ìŠ¤ë“¤
    â””â”€â”€ Error
        â”œâ”€â”€ OutOfMemoryError
        â”œâ”€â”€ StackOverflowError
        â””â”€â”€ ê¸°íƒ€ Errorì˜ ì„œë¸Œí´ë˜ìŠ¤ë“¤
    ```

### ë¦¬ìŠ¤íŠ¸

```kotlin
fun main() {
  val ints = listOf(5, 13, 9)

  // ints.add(11) // âŒ

  for (i in ints) {
    if (i > 10) {
      trace(i)
    }
  }

  val chars = mutableListOf('a', 'b', 'c')
  chars.add('d') // â­•ï¸
  chars += 'e'

  trace(chars)
  trace eq """
    13
    [a, b, c, d, e]
  """
}
```

- ë¦¬ìŠ¤íŠ¸ëŠ” ìˆœì°¨ì ì¸ ì½œë ‰ì…˜ íƒ€ì…ì´ë‹¤.
- listOf()ëŠ” ì½ê¸°ì „ìš© ë¦¬ìŠ¤íŠ¸(ë¶ˆë³€ë¦¬ìŠ¤íŠ¸)ë¥¼ ìƒì„±í•œë‹¤. ê·¸ë˜ì„œ `add()`ë¥¼ í†µí•´ì„œ ìƒíƒœë¥¼ ë³€ê²½í•  ìˆ˜ ì—†ë‹¤. forë¬¸ìœ¼ë¡œ ìˆœíšŒê°€ëŠ¥í•˜ë‹¤.
- mutableListOf()ëŠ” ë³€ê²½ê°€ëŠ¥í•œ ë¦¬ìŠ¤íŠ¸(ê°€ë³€ë¦¬ìŠ¤íŠ¸)ë¥¼ ìƒì„±í•œë‹¤. `add()` ë‚˜ `+= ì—°ì‚°`ì„ í†µí•´ì„œ ë¦¬ìŠ¤íŠ¸ì˜ ìƒíƒœë¥¼ ë³€ê²½í•  ìˆ˜ ìˆë‹¤.

```kotlin
fun main() {
    val first = mutableListOf(1)
    val second: List<Int> = first
    second eq listOf(1)
    first += 2

    // second += 2  // âœ… ì´ë ‡ê²Œ ë³€ê²½í•  ìˆ˜ ì—†ìŒ

    // second sees the change:
    second eq listOf(1, 2)
}
```

- [ì±…_p183] `ì½ê¸°ì „ìš© ë¦¬ìŠ¤íŠ¸ëŠ” ê²°ê³¼ ë‚´ë¶€ë¥¼ ë³€ê²½í•  ìˆ˜ ì—†ëŠ” ë¶ˆë³€ ë¦¬ìŠ¤íŠ¸ì™€ëŠ” ë‹¤ë¥´ë‹¤` ë¼ê³  í‘œí˜„

  - ì—¬ê¸°ì„œ ë§í•˜ëŠ” ì½ê¸°ì „ìš© ë¦¬ìŠ¤íŠ¸ëŠ” listOf()ì— ì˜í•´ì„œ ìƒì„±ëœ ë¦¬ìŠ¤íŠ¸ë¥¼ ë§í•˜ëŠ” ê²ƒì´ ì•„ë‹ˆê³  ì§„ì§œ "ì½ê¸°ì „ìš©"ìœ¼ë¡œ ì‚¬ìš©í•˜ëŠ” ë¦¬ìŠ¤íŠ¸ë¥¼ ë§í•˜ëŠ” ê²ƒì´ê³ , ë¶ˆë³€ë¦¬ìŠ¤íŠ¸ëŠ” listOf()ë¡œ ìƒì„±ëœ ê²ƒì„ ë§í•œë‹¤ê³  ì´í•´í–ˆë‹¤. ì½”ë“œë¥¼ ë³´ë©´ ì¢€ ë” ì´í•´í•  ìˆ˜ ìˆë‹¤.

- ì½”ë“œ ì‚´í´ë³´ê¸°

  - first : ê°€ë³€ë¦¬ìŠ¤íŠ¸
  - second : firstì˜ ì°¸ì¡°ê°’ì„ ì§€ë‹ˆê³  ìˆì§€ë§Œ, `List<Int>` ë¡œ ì„ ì–¸ë˜ì–´ì„œ íƒ€ì…ìƒ ì½ê¸° ì „ìš© ë¦¬ìŠ¤íŠ¸ê°€ ë˜ì—ˆê¸°ë•Œë¬¸ì— ì§ì ‘ ë³€ê²½ì´ ë¶ˆê°€ëŠ¥í•˜ë‹¤.
  - firstëŠ” ë³€ê²½ ê°€ëŠ¥í•˜ê¸° ë•Œë¬¸ì— firstë¥¼ ë³€ê²½í•˜ë©´ ì´ì™€ ê°™ì€ ì°¸ì¡°ê°’ì„ ê°€ì§€ secondë„ ë³€ê²½ì´ ëœë‹¤.

    â†’ ê·¸ë˜ì„œ secondëŠ” `ì½ê¸° ì „ìš©ë·°`ë¥¼ ì œê³µí•˜ëŠ” ë¦¬ìŠ¤íŠ¸ê°€ ëœë‹¤. ì´ëŸ° ì˜ë¯¸ì—ì„œ ì½ê¸°ì „ìš© ë¦¬ìŠ¤íŠ¸ì™€ ë¶ˆë³€ ë¦¬ìŠ¤íŠ¸ê°€ ë‹¤ë¥´ë‹¤ê³  í‘œí˜„í•œ ê²ƒì´ë¼ê³  ì´í•´í•˜ì˜€ë‹¤.

```kotlin
fun main() {
  val wocky = """
    Twas brillig, and the slithy toves
      Did gyre and gimble in the wabe:
    All mimsy were the borogoves,
      And the mome raths outgrabe.
  """.trim().split(Regex("\\W+"))

  trace(wocky.take(5))
  trace(wocky.slice(6..12))
  trace(wocky.slice(6..18 step 2))
  trace(wocky.sorted().takeLast(5))
  trace(wocky.sorted().distinct().takeLast(5))

  trace eq """
    [Twas, brillig, and, the, slithy]
    [Did, gyre, and, gimble, in, the, wabe]
    [Did, and, in, wabe, mimsy, the, And]
    [the, the, toves, wabe, were]
    [slithy, the, toves, wabe, were]
  """
}
```

- `split(Regex("\\W+"))` : wockyë¥¼ ê³µë°± ë° , ë“±ìœ¼ë¡œ ì´ë£¨ì–´ì§„ ë¬¸ìë¥¼ ê¸°ì¤€ìœ¼ë¡œ ìë¥´ë©´ ë¬¸ìë¡œ ì´ë£¨ì–´ì§„ ë¦¬ìŠ¤íŠ¸ë¥¼ ë°˜í™˜í•œë‹¤.

  - ê²°ê³¼ê°’ : `[Twas, brillig, and, the, slithy, toves, Did, gyre, and, gimble, in, the, wabe, All, mimsy, were, the, borogoves, And, the, mome, raths, outgrabe]`

- take(), slice(), sorted(), takeLast(), distinct() : **ëª¨ë‘ ìƒˆë¡œìš´ ë¦¬ìŠ¤íŠ¸ë¥¼ ë°˜í™˜**í•œë‹¤.
  - take(n) : ì•ì—ì„œ nê°œê¹Œì§€ ë¦¬ìŠ¤íŠ¸ ë°˜í™˜
  - slice(êµ¬ê°„) : êµ¬ê°„ì— ì¼ì¹˜í•˜ëŠ” ìƒˆë¡œìš´ ë¦¬ìŠ¤íŠ¸ ë°˜í™˜
  - sorted() : ì •ë ¬ëœ ìƒˆë¡œìš´ ë¦¬ìŠ¤íŠ¸ ë°˜í™˜
    - sort() : MutableListì—ì„œë§Œ ì‘ë™, ì›ë³¸ë¦¬ìŠ¤íŠ¸ ë³€ê²½
  - takeLast(n) : ë’¤ì—ì„œ nê°œê¹Œì§€ í¬í•¨ëœ ë¦¬ìŠ¤íŠ¸ ë°˜í™˜
  - distinct() : ì¤‘ë³µëœ ìš”ì†Œë¥¼ ì œê±°ëœ ë¦¬ìŠ¤íŠ¸ ë°˜í™˜

### íŒŒë¼ë¯¸í„°í™”í•œ íƒ€ì…

```kotlin
fun main() {
  val numbers: List<Int> = listOf(1, 2, 3)
  val strings: List<String> =
    listOf("one", "two", "three")
  numbers eq "[1, 2, 3]"
  strings eq "[one, two, three]"
  toCharList("seven") eq "[s, e, v, e, n]"
}

fun toCharList(s: String): List<Char> =
  s.to
```

- ì»¨ë„¤ì´ë„ˆ(ì½œë ‰ì…˜) ì•ˆì˜ ë‹´ê¸°ëŠ” íƒ€ì…ì´ ë¬´ìŠ¨ íƒ€ì…ì¸ì§€ë¥¼ ì ì–´ì£¼ëŠ” ê²ƒì„ **íƒ€ì… íŒŒë¼ë¯¸í„°**ë¼ê³  í•œë‹¤.
  - `List<Int>` : Intì˜ List â†’ List of Int
  - `List<String>` : Stringì˜ List â†’ List of String

### ê°€ë³€ì¸ì ëª©ë¡

```kotlin
fun varargs(s: String, vararg ints: Int) {
  for (i in ints) {
    trace("$i")
  }
  trace(s)
}

fun main() {
  varargs("primes", 5, 7, 11, 13, 17, 19, 23)
  trace eq "5 7 11 13 17 19 23 primes"
}
```

- vararg í‚¤ì›Œë“œ : ê°€ë³€ì¸ìëª©ë¡ì„ ëœ»í•˜ëŠ” ë§(var + arg)ë¡œ í•¨ìˆ˜ê°€ ê°™ì€ íƒ€ì…ì˜ ì¸ìë¥¼ ë°›ê²Œ í•´ì£¼ëŠ” ê²ƒì„ ë§í•œë‹¤.
- varargëŠ” Array íƒ€ì…ì´ë‹¤. í•¨ìˆ˜ ì •ì˜ì—ì„œ varargëŠ” ìµœëŒ€ í•˜ë‚˜ë§Œ ì§€ì •í•  ìˆ˜ ìˆê³ , ì¼ë°˜ì ìœ¼ë¡œ ë§ˆì§€ë§‰ íŒŒë¼ë¯¸í„°ë¥¼ varargë¡œ ì§€ì •í•œë‹¤.(ë‹¤ë¥¸ ìœ„ì¹˜ì— ìˆì–´ë„ ì§€ì • ê°€ëŠ¥)

```kotlin
fun main() {
  val array = intArrayOf(4, 5)      // [1]
  varargs("x", 1, 2, 3, *array, 6)  // [2]
  val list = listOf(9, 10, 11)
  varargs(
    "y", 7, 8, *list.toIntArray())  // [3]
  trace eq "1 2 3 4 5 6 x 7 8 9 10 11 y"
}
```

- `*` ìŠ¤í”„ë ˆë“œ ì—°ì‚°ì(í¼ì¹¨ ì—°ì‚°ì)ë¥¼ í†µí•´ì„œ íŒŒë¼ë¯¸í„°ë¡œ Arrayë¥¼ ì „ë‹¬í•  ìˆ˜ ìˆë‹¤.
- [3] : `*list.toIntArray()`
  - listë¥¼ toIntArray()ì— ì˜í•´ì„œ Array íƒ€ì…ìœ¼ë¡œ ë³€í™˜í•œë‹¤.
  - ì—°ì‚°ìë¡œ í¼ì³ì„œ `9,10,11`ë¡œ ì „ë‹¬í•˜ê²Œ ëœë‹¤.

### ì§‘í•© / ë§µ / í”„ë¡œí¼í‹° ì—°ì‚°ì

> ì•ì—ì„œ í–ˆë˜ ë¶€ë¶„ì´ë¼ ìƒëµ...ğŸ¥²

## Atom30 í™•ì¥ í•¨ìˆ˜

- í™•ì¥ í•¨ìˆ˜(extension function) ì •ì˜

  ```kotlin
  fun String.singleQuote() = "'$this'"
  fun String.doubleQuote() = "\"$this\""

  fun main() {
    "Hi".singleQuote() eq "'Hi'"
    "Hi".doubleQuote() eq "\"Hi\""
  }
  ```

  - ê¸°ì¡´ í´ë˜ìŠ¤ì—ì„œ ë©¤ë²„ í•¨ìˆ˜ë¥¼ ì¶”ê°€í•˜ëŠ” ê²ƒê³¼ ê°™ì€ íš¨ê³¼ë¥¼ ë‚´ëŠ” í•¨ìˆ˜ë¥¼ í™•ì¥ í•¨ìˆ˜ë¼ê³  í•œë‹¤. ê·¸ë˜ì„œ ë§ˆì¹˜ ê¸°ì¡´ í´ë˜ìŠ¤ì˜ ë©¤ë²„ í•¨ìˆ˜ì²˜ëŸ¼ í˜¸ì¶œí•´ì„œ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.

  - `fun ìˆ˜ì‹ íƒ€ì….í™•ì¥í•¨ìˆ˜() { .... }`

    - ì •ì˜ì—ì„œ ì íŒ **ìˆ˜ì‹ íƒ€ì…** ì´ë€ : í™•ì¥í•  ëŒ€ìƒ íƒ€ì…ì„ ì˜ë¯¸í•˜ê³ , ìˆ˜ì‹ ê°ì²´ íƒ€ì…(receiver type)ì´ë¼ê³  ë¶€ë¥¸ë‹¤.

- ì„í¬íŠ¸ ë°©ë²•

  ```kotlin
    import atomictest.eq
    import extensionfunctions.doubleQuote // âœ…
    import extensionfunctions.singleQuote // âœ…

    fun main() {
      "Single".singleQuote() eq "'Single'"
      "Double".doubleQuote() eq "\"Double\""
    }
  ```

- í™•ì¥ í•¨ìˆ˜ì—ì„œì˜ this

  ```kotlin
    fun String.strangeQuote() =
      this.singleQuote().singleQuote()

    fun String.tooManyQuotes() =
      doubleQuote().doubleQuote() // âœ…

    fun main() {
      "Hi".strangeQuote() eq "''Hi''"
      "Hi".tooManyQuotes() eq "\"\"Hi\"\""
    }
  ```

  - í´ë˜ìŠ¤ ë‚´ë¶€ì—ì„œ thisë¥¼ ìƒëµê°€ëŠ¥í•œ ê²ƒê³¼ ë§ˆì°¬ê°€ì§€ë¡œ í™•ì¥ í•¨ìˆ˜ì—ì„œë„ ìƒëµ ê°€ëŠ¥

- í™•ì¥ í•¨ìˆ˜ì˜ ì¥ì  : ê°„ë‹¨í•œ ì½”ë“œ ìƒì„±

  ```kotlin
    class Book(val title: String)

    fun Book.categorize(category: String) =
      """title: "$title", category: $category"""

    fun main() {
      Book("Dracula").categorize("Vampire") eq
        """title: "Dracula", category: Vampire"""
    }
  ```

  - í™•ì¥ í•¨ìˆ˜ëŠ” ìˆ˜ì‹  ê°ì²´ íƒ€ì…ì˜ í”„ë¡œí¼í‹°ê°€ publicì¸ ê²½ìš°ì—ë§Œ ì ‘ê·¼ì´ ê°€ëŠ¥í•˜ë‹¤.
  - `class Book(private val title: String)` : error ë°œìƒ (`Cannot access 'title': it is private in 'Book'`)

  - ì •ë§ ê°„ê²°í•˜ë‹ˆ?? : ìŒ...ğŸ¤”

    > í™•ì¥í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ì§€ ì•ŠëŠ” ê°™ì€ ê²°ê³¼ë¥¼ ì–»ì–´ë‚´ëŠ” ì½”ë“œ

    ```kotlin
      class Book(val title: String) {

          fun categorize(category: String) =
              """title: "$title", category: $category"""
      }

      fun main() {
          val book = Book("Dracula")
          book.categorize("Vampire") eq
                  """title: "Dracula", category: Vampire"""
      }
    ```

- í™•ì¥í•¨ìˆ˜ ìœ ë¬´ ë¹„êµ (feat.chatGPT)

  - í™•ì¥í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ì§€ ì•Šì€ ê²ƒ

    ```kotlin
    fun capitalizeFirstLetter(str: String): String {
        if (str.isEmpty()) return str
        return str.substring(0, 1).uppercase() + str.substring(1)
    }

    fun main() {
        val strings = listOf("hello", "world", "kotlin")
        val capitalizedStrings = strings.map { capitalizeFirstLetter(it) }

        println(capitalizedStrings) // [Hello, World, Kotlin]
    }
    ```

  - í™•ì¥í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•œ ê²ƒ

    ```kotlin
    // String íƒ€ì…ì— ëŒ€í•œ í™•ì¥ í•¨ìˆ˜ ì •ì˜
    fun String.capitalizeFirstLetter(): String {
        if (this.isEmpty()) return this
        return this.substring(0, 1).uppercase() + this.substring(1)
    }

    fun main() {
        val strings = listOf("hello", "world", "kotlin")
        val capitalizedStrings = strings.map { it.capitalizeFirstLetter() }

        println(capitalizedStrings) // [Hello, World, Kotlin]
    }
    ```

    - ê°€ë…ì„± í–¥ìƒ: ê¸°ì¡´ í´ë˜ìŠ¤ì˜ ë©”ì„œë“œë¥¼ í˜¸ì¶œí•˜ëŠ” ê²ƒì²˜ëŸ¼ ì½”ë“œê°€ ìì—°ìŠ¤ëŸ½ê³  ì½ê¸° ì‰½ë‹¤.
      - `it.capitalizeFirstLetter()`
    - ìº¡ìŠí™”: í™•ì¥ í•¨ìˆ˜ë¥¼ í†µí•´ íŠ¹ì • í´ë˜ìŠ¤ì— ê´€ë ¨ëœ ë™ì‘ì„ í•´ë‹¹ í´ë˜ìŠ¤ ë‚´ë¶€ë¡œ ìº¡ìŠí™” í•  ìˆ˜ ìˆë‹¤. ì´ëŠ” ì½”ë“œì˜ ì‘ì§‘ë„ë¥¼ ë†’ì´ê³ , ë‹¤ë¥¸ ê³³ì—ì„œ ì¬ì‚¬ìš©í•  ë•Œ ìœ ìš©í•˜ë‹¤.
    - ~~ì½”ë“œ ì¤‘ë³µ ê°ì†Œ: ì—¬ëŸ¬ ê³³ì—ì„œ ë™ì¼í•œ ì‘ì—…ì„ ìˆ˜í–‰í•´ì•¼ í•˜ëŠ” ê²½ìš°, í™•ì¥ í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ë©´ ì½”ë“œ ì¤‘ë³µì„ ì¤„ì¼ ìˆ˜ ìˆë‹¤. í•„ìš”í•  ë•Œë§ˆë‹¤ ë³„ë„ì˜ í•¨ìˆ˜ë¥¼ importí•˜ì—¬ ì‚¬ìš©í•˜ëŠ” ëŒ€ì‹ , í™•ì¥ í•¨ìˆ˜ë¡œ ì •ì˜ëœ ë©”ì„œë“œë¥¼ í˜¸ì¶œí•˜ë©´ ëœë‹¤.~~
    - ê¸°ì¡´ ì½”ë“œ ìˆ˜ì • ë¶ˆí•„ìš”: í™•ì¥ í•¨ìˆ˜ëŠ” ê¸°ì¡´ í´ë˜ìŠ¤ë‚˜ ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ìˆ˜ì •í•˜ì§€ ì•Šê³ ë„ ìƒˆë¡œìš´ ê¸°ëŠ¥ì„ ì¶”ê°€í•  ìˆ˜ ìˆê²Œ í•œë‹¤. ì´ëŠ” ì™¸ë¶€ ë¼ì´ë¸ŒëŸ¬ë¦¬ë‚˜ ì„œë“œíŒŒí‹° ì½”ë“œë¥¼ ì‚¬ìš©í•  ë•Œ íŠ¹íˆ ìœ ìš©í•  ìˆ˜ ìˆë‹¤.
