# Atomic Kotlin 26 ~ 30

<details>
  <summary>Collection Hierarchy</summary>

![collection-hierarchy](../screenshots/collection-hierarchy.png)

- Red Box : ì—¬ê¸°ì„œ ë°°ìš¸ Collectionë“¤
- Blue Box : ì—¬ê¸°ì„  ë°°ìš°ì§€ì•Šì§€ë§Œ ë‹¤ì–‘í•œ Mapì˜ ì¢…ë¥˜ ([ê´€ë ¨ë§í¬](https://medium.com/depayse/kotlin-collections-2-map-hashmap-treemap-linkedhashmap-76195842f0c8))

</details>

## Atom26 ì§‘í•©(Set)

- Setì˜ ìƒì„± : ë¦¬ìŠ¤íŠ¸ì™€ ë§ˆì°¬ê°€ì§€ë¡œ ë‘ê°€ì§€ ìƒì„±í•¨ìˆ˜ ì œê³µ

  - `setOf()` â†’ ì½ê¸°ì „ìš© Set
  - `mutableSetOf()` â†’ ê°€ë³€ Set

- Set ì˜ íŠ¹ì§•

  ```kotlin
  fun main() {
    // 1
    val intSet = setOf(1, 1, 2, 3, 9, 9, 4)
    intSet eq setOf(1, 2, 3, 4, 9)

    // 2
    setOf(1, 2) eq setOf(2, 1)

    // 3
    (9 in intSet) eq true
    (99 in intSet) eq false

    intSet.contains(9) eq true
    intSet.contains(99) eq false

    // 4
    intSet.containsAll(setOf(1, 9, 2)) eq true

    // 5 : í•©ì§‘í•©
    intSet.union(setOf(3, 4, 5, 6)) eq
      setOf(1, 2, 3, 4, 5, 6, 9)

    // 6 : êµì§‘í•©
    intSet intersect setOf(0, 1, 2, 7, 8) eq
      setOf(1, 2)

    // 7 : ì°¨ì§‘í•©
    intSet subtract setOf(0, 1, 9, 10) eq
      setOf(2, 3, 4)
    intSet - setOf(0, 1, 9, 10) eq
      setOf(2, 3, 4)
  }

  ```

  - ì¤‘ë³µë˜ì§€ ì•ŠëŠ”ë‹¤.
  - ìˆœì„œê°€ ì—†ë‹¤
  - `in`, `contains()`ë¥¼ í†µí•´ì„œ ìš”ì†Œì¸ì§€ ì—¬ë¶€ë¥¼ í™•ì¸í•  ìˆ˜ ìˆë‹¤.
  - `containsAll()` ë¥¼ í†µí•´ì„œ Setë¼ë¦¬ì˜ í¬í•¨ì—¬ë¶€ë¥¼ í™•ì¸í•  ìˆ˜ ìˆë‹¤.
  - Setì˜ ì—°ì‚° ì§€ì›(ë°´ ë‹¤ì´ì–´ê·¸ë¨ ì—°ì‚°)
    - í•©ì§‘í•©(union, +), êµì§‘í•©(intersect), ì°¨ì§‘í•©(subtract, -)
      - ì í‘œê¸°ë²• : `set1.union(set2)`
      - ì¤‘ìœ„í‘œê¸°ë²• : `set1 union set2`, `set1 + set2`

- ì¤‘ë³µì œê±°ì—ì„œì˜ Set í™œìš©

  ```kotlin
    fun main() {
      val list = listOf(3, 3, 2, 1, 2)
      list.toSet() eq setOf(1, 2, 3)
      list.distinct() eq listOf(3, 2, 1)
      "abbcc".toSet() eq setOf('a', 'b', 'c')
    }
  ```

  - ë¦¬ìŠ¤íŠ¸ì—ì„œ ì§‘í•©ìœ¼ë¡œ ë³€ê²½í•˜ì—¬ ì¤‘ë³µì„ ì œê±°í•  ìˆ˜ ìˆë‹¤.
    - `toSet()` ì´ìš©
  - `distinct()` ë¥¼ ì´ìš©í•˜ì—¬ ì¤‘ë³µì„ ì œê±°í•  ìˆ˜ ìˆë‹¤.
    - Array, Listì—ì„œ ì‚¬ìš©í•˜ì—¬ ì¤‘ë³µì„ ì œê±°í•œ Array ë‚˜ Listë¥¼ ë°˜í™˜í•œë‹¤. ë‹¨, ìˆœì„œëŠ” ìœ ì§€ëœë‹¤.
    - Setì—ì„œë„ distinct() ë©¤ë²„í•¨ìˆ˜ ì¡´ì¬í•˜ì§€ë§Œ, Setì˜ íŠ¹ì„±ìƒ ì˜ë¯¸ì—†ëŠ” ë©¤ë²„í•¨ìˆ˜ì´ë‹¤. ë‹¨ì§€ Collection ì¸í„°í˜ì´ìŠ¤ì—ì„œ ìƒì†ë˜ì–´ì„œ ìˆëŠ” ê²ƒì´ë‹¤.
  - `ë¬¸ìì—´.toSet()` ì„ í†µí•´ì„œë„ ì¤‘ë³µì„ ì œê±°í•  ìˆ˜ ìˆë‹¤.

  - ìœ„ì˜ ë‚´ìš©ì„ í™œìš©í•œ ë¬¸ìì—´ì˜ ì¤‘ë³µì„ ì—†ì• ëŠ” ë˜ë‹¤ë¥¸ ë°©ë²•
    ```kotlin
      val b = "helloworld".toList()
      val c = b.distinct()
      println(c)
    ```
    > ë‹¹ì—°í•˜ê²Œë„ íƒ€ì…ì€ ë‹¤ë¦„!

- MutableSet

  - ë¦¬ìŠ¤íŠ¸ì™€ ë§ˆì°¬ê°€ì§€ë¡œ +/- ì—°ì‚°ì„ í†µí•´ì„œ ì›ì†Œë¥¼ ì¶”ê°€ ì‚­ì œê°€ ê°€ëŠ¥í•˜ë‹¤.

    ```kotlin
      fun main() {
        val mutableSet = mutableSetOf<Int>()
        mutableSet += 42
        mutableSet += 42
        mutableSet eq setOf(42)
        mutableSet -= 42
        mutableSet eq setOf<Int>()
      }
    ```

<details>
  <summary>ì°¸ê³ </summary>

```kotlin
fun main() {
    val list = mutableListOf(1,2,3,4) // o.k
    var list = mutableListOf(1,2,3,4) // o.k
    val list = listOf(1,2,3,4) // val not reassign
    var list = listOf(1,2,3,4) // o.k
    list += 5
    println(list)
    list -= 1
    println(list)
}
```

> [ì‹¤í–‰ë§í¬](https://pl.kotl.in/ij3t9Mgxs)

í˜„ìƒì ìœ¼ë¡œë§Œ ë”°ì§€ë©´, valì— í• ë‹¹í•˜ê³  ì½ê¸°ì „ìš© ìƒì„±í•¨ìˆ˜ì¸ listOfë¡œ ìƒì„±í•˜ëŠ” ê²½ìš°ì—ë§Œ ì—°ì‚°ì´ ë¶ˆê°€ëŠ¥í•˜ë‹¤.

</details>

## Atom27 ë§µ

> ë§µì€ í‚¤ì™€ ê°’ì„ ì—°ê²°ì‹œì¼œì£¼ê¸° ë•Œë¬¸ì— ì´ë¥¼ `ì—°ê´€ ë°°ì—´(associative array)` ë¼ê³  ë¶€ë¥´ê¸°ë„ í•œë‹¤.

- Mapì˜ ìƒì„±

  - í‚¤-ê°’ ìŒì„ mapOf()ì— ì „ë‹¬
  - í‚¤-ê°’ ì „ë‹¬ í˜•ì‹ : `í‚¤ to ê°’`

  ```kotlin
  fun main() {
      val constants = mapOf(
      "Pi" to 3.141,
      "e" to 2.718,
      "phi" to 1.618
    )
    constants eq
      "{Pi=3.141, e=2.718, phi=1.618}"
  }
  ```

- Mapì˜ íŠ¹ì§•

  ```kotlin
  fun main() {

  // 1) ì ‘ê·¼
  constants["e"] eq 2.718
  constants.keys eq setOf("Pi", "e", "phi")
  constants.values eq "[3.141, 2.718, 1.618]"

  // 2) ë°˜ë³µ1
  var s = ""
  for (entry in constants) {
    s += "${entry.key}=${entry.value}, "
  }
  s eq "Pi=3.141, e=2.718, phi=1.618,"


  // 3) ë°˜ë³µ2
  s = ""
  for ((key, value) in constants)
    s += "$key=$value, "
  s eq "Pi=3.141, e=2.718, phi=1.618,"
  }
  ```

  - ì ‘ê·¼

    - `map[íŠ¹ì •í‚¤]` : íŠ¹ì • í‚¤ë¥¼ ê°€ì§„ ê°’ì„ ì–»ì„ ìˆ˜ ìˆë‹¤.
    - `map.keys` : mapì˜ ëª¨ë“  í‚¤ë¥¼ ê°€ì ¸ì˜¨ë‹¤.

      â†’ í•˜ë‚˜ì˜ mapì•ˆì—ì„œ í‚¤ëŠ” ìœ ì¼í•˜ê¸° ë•Œë¬¸ì— ê²°êµ­ Setì´ ìƒì„±ëœë‹¤. ì‹¤ì œë¡œ ë¦¬í„´ íƒ€ì…ë„ Setì´ë‹¤.

      ```kotlin
      public val keys: Set<K>
      ```

    - `map.values` : mapì˜ ëª¨ë“  ê°’ì„ ê°€ì ¸ì˜¨ë‹¤.

      ```kotlin
      public val values: Collection<V>
      ```

  - ë°˜ë³µ(Iterate)

    - `for (entry in constants)` : for loop
      - `entry.key` : í‚¤
      - `entry.value` : ê°’
    - `for ((key, value) in constants)` : unpacking for loop
      - key, value ë¡œ ì§ì ‘ ì ‘ê·¼

- MutableMap

  ```kotlin
    fun main() {
      val m =
        mutableMapOf(5 to "five", 6 to "six")
      m[5] eq "five"

      m[5] = "5ive"
      m[5] eq "5ive"

      m += 4 to "four"
      m eq mapOf(5 to "5ive",
        4 to "four", 6 to "six")
    }
  ```

  - `m[5] = "5ive"` : ê¸°ì¡´ 5 ë¥¼ ë³€ê²½í•  ìˆ˜ ìˆë‹¤.
  - `m += 4 to "four"` : ëª…ì‹œì ìœ¼ë¡œ í‚¤ì™€ ê°’ì„ ì¶”ê°€í•  ìˆ˜ ìˆë‹¤.
  - mapof(), mutableMapOf()ëŠ” Mapì— ì „ë‹¬ëœ ìˆœì„œë¥¼ ìœ ì§€í•´ì£¼ì§€ë§Œ, ë‹¤ë¥¸ Map(ìƒë‹¨ì˜ hierarchy ì°¸ê³ )ì—ì„œëŠ” ìˆœì„œê°€ ë³´ì¥ë˜ì§€ ì•Šì„ ìˆ˜ ìˆë‹¤.

- ReadOnlyMap

  ```kotlin
    fun main() {
      val m = mapOf(5 to "five", 6 to "six")
      m[5] eq "five"

      // m[5] = "5ive" // ë¶ˆê°€ëŠ¥
      // m += (4 to "four") // ë¶ˆê°€ëŠ¥
      m + (4 to "four") // mì„ ë³€ê²½í•  ìˆ˜ ì—†ìŒ
      m eq mapOf(5 to "five", 6 to "six")

      val m2 = m + (4 to "four")
      m2 eq mapOf(
        5 to "five", 6 to "six", 4 to "four")
  }
  ```

  - ì½ê¸°ì „ìš© Map : ìˆ˜ì •, ì¶”ê°€ ë¶ˆê°€ëŠ¥
  - ì½ê¸°ì „ìš© Mapì—ì„œ í‚¤-ê°’ì„ ì¶”ê°€í•˜ëŠ” ë°©ë²•ì€ ìƒˆë¡œìš´ Mapì„ ìƒì„±í•´ì•¼í•œë‹¤.

- ë§µì˜ ê¸°ë³¸ê°’ ì„¤ì •

  ```kotlin
  fun main() {
    val map = mapOf('a' to "attempt")
    map['b'] eq null

    capture {
      map.getValue('b')
    } eq "NoSuchElementException: " +
      "Key b is missing in the map."

    map.getOrDefault('a', "??") eq "attempt"
    map.getOrDefault('b', "??") eq "??"
  }
  ```

  - Mapì—ì„œ íŠ¹ì • í‚¤ë¡œ ì ‘ê·¼í• ë•Œ, í‚¤ì— ëŒ€í•œ ê°’ì´ ì—†ìœ¼ë©´ nullì„ ë°˜í™˜í•œë‹¤.
  - `getValue()` ë©¤ë²„í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ì—¬ ì ‘ê·¼í•˜ë©´, ê°’ì´ ì—†ìœ¼ë©´ `NoSuchElementException` ë¥¼ ë°˜í™˜í•œë‹¤.
  - ê°€ì¥ ì¢‹ì€ ë°©ë²•ì€ `getOrDefault(key, defaultValue)` ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ë‹¤. í‚¤ë¡œ ì ‘ê·¼í•  ë•Œ, ê°’ì´ ì—†ìœ¼ë©´, ì„¤ì •ëœ ê¸°ë³¸ê°’ì„ ë°˜í™˜í•œë‹¤.

- í´ë˜ìŠ¤ ì¸ìŠ¤í„´ìŠ¤ë¥¼ Mapì— ì €ì¥í•˜ëŠ” ë°©ë²•

  ```kotlin
  class Contact(
    val name: String,
    val phone: String
  ) {
    override fun toString(): String {
      return "Contact('$name', '$phone')"
    }
  }

  fun main() {
    val miffy = Contact("Miffy", "1-234-567890")
    val cleo = Contact("Cleo", "098-765-4321")
    val contacts = mapOf(
      miffy.phone to miffy,
      cleo.phone to cleo)
    contacts["1-234-567890"] eq miffy
    contacts["1-111-111111"] eq null
  }
  ```

  - `miffy` ì™€ `cleo` ì¸ìŠ¤í„´ìŠ¤ ìƒì„±
  - ê° ì „í™”ë²ˆí˜¸ì— ë§ëŠ” ì¸ìŠ¤í„´ìŠ¤ë¥¼ ì €ì¥í•  ìˆ˜ ìˆë‹¤.(ì¸ìŠ¤í„´ìŠ¤ ë§µí•‘)

    â†’ ì¸ìŠ¤í„´ìŠ¤ë¥¼ í‚¤ë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ”ë°, ì´ ë°©ë²•ì€ ë’¤ì—ì„œ í•™ìŠµ

## Atom28 í”„ë¡œí¼í‹° ì ‘ê·¼ì

> í´ë˜ìŠ¤ ë‚´ë¶€ì— ì„ ì–¸ëœ í”„ë¡œí¼í‹°ì— ëŒ€í•œ `getter`ì™€ `setter` ë¥¼ ì–´ë–»ê²Œ ì‚¬ìš©í•˜ëŠ”ì§€ì— ëŒ€í•´ì„œ ì•Œì•„ë³¸ë‹¤.

- í”„ë¡œí¼í‹° ì ‘ê·¼

  ```kotlin
    class Data(var i: Int)

    fun main() {
      val data = Data(10)
      data.i eq 10  // get
      data.i = 20   // set
    }
  ```

  - ì¸ìŠ¤í„´ìŠ¤ ë‚´ë¶€ì˜ í”„ë¡œí¼í‹°ë¥¼ í†µí•´ì„œ `get`ê³¼ `set`ì„ í•  ìˆ˜ ìˆë‹¤.

- í”„ë¡œí¼í‹° ì ‘ê·¼ ì»¤ìŠ¤í„°ë§ˆì´ì§•

  ```kotlin
  class Default {
    var i: Int = 0
      get() {
        trace("get()")
        return field
      }
      set(value) {
        trace("set($value)")
        field = value
      }
  }

  fun main() {
    val d = Default()
    d.i = 2
    trace(d.i)
    trace eq """
      set(2)
      get()
      2
    """
  }
  ```

  - í´ë˜ìŠ¤ ë‚´ë¶€ì—ì„œ í”„ë¡œí¼í‹° ì •ì˜ ì´í›„ì— `getter`ì™€ `setter`ë¥¼ ì •ì˜í•  ìˆ˜ ìˆë‹¤.
  - getterì™€ setterë¥¼ ì •ì˜í•˜ëŠ” ìˆœì„œëŠ” ì¤‘ìš”í•˜ì§€ ì•Šë‹¤.
  - getterì™€ setter ë‚´ë¶€ì—ë§Œ ì¡´ì¬í•˜ëŠ” `field` ë¼ëŠ” ì´ë¦„ì„ ì‚¬ìš©í•´ ì €ì¥ëœ ê°’ì— ì§ì ‘ ì ‘ê·¼ ê°€ëŠ¥í•˜ë‹¤.
  - getterì™€ setter ì•ˆì—ì„œ ì»¤ìŠ¤í„°ë§ˆì´ì§•ì´ ê°€ëŠ¥í•˜ë‹¤. ìœ„ì—ì„œëŠ” ê°’ì„ ì½ê³  ì“°ëŠ” ê³¼ì •ì—ì„œ ì¶”ê°€ ì •ë³´ê°€ ì¶œë ¥ë  ìˆ˜ ìˆë„ë¡ ë§Œë“  ê²ƒì´ë‹¤.

- private

  ```kotlin
  class Counter {
    var value: Int = 0 // âœ…
      private set      // âœ…
    fun inc() = value++
  }

  fun main() {
    val counter = Counter()

    // counter.value++

    repeat(10) {
      counter.inc()
    }
    counter.value eq 10
  }
  ```

  - valueì— ëŒ€í•œ ì ‘ê·¼ì ëª¨ë‘ private ì„¤ì • : `private var value: Int = 0`
  - ìœ„ ì½”ë“œëŠ” `getterëŠ” public`ì´ê³  `setterëŠ” private` ìœ¼ë¡œ ì„¤ì •í•œ ê²ƒìœ¼ë¡œ ë“¤ì—¬ì“°ê¸° í˜•ì‹ì„ ë§ì¶°ì•¼í•˜ëŠ” ê²ƒìœ¼ë¡œ ë³´ì¸ë‹¤.(ì¸í…”ë¦¬ì œì´ì—ì„œ ìë™ìœ¼ë¡œ ë“¤ì—¬ì“°ê¸°ë¨)
  - [TEST] `counter.value++` â†’ error : Cannot assign to 'value': the setter is private in 'Counter'

- fieldë¥¼ ì‚¬ìš©í•˜ì§€ ì•ŠëŠ” ì ‘ê·¼ì

  ```kotlin
  class Hamster(val name: String)

  class Cage(private val maxCapacity: Int) {
    private val hamsters =
      mutableListOf<Hamster>()

    val capacity: Int
      get() = maxCapacity - hamsters.size
    val full: Boolean
      get() = hamsters.size == maxCapacity

    fun put(hamster: Hamster): Boolean =
      if (full)
        false
      else {
        hamsters += hamster
        true
      }
    fun take(): Hamster =
      hamsters.removeAt(0)
  }

  fun main() {
    val cage = Cage(2)
    cage.full eq false
    cage.capacity eq 2
    cage.put(Hamster("Alice")) eq true
    cage.put(Hamster("Bob")) eq true
    cage.full eq true
    cage.capacity eq 0
    cage.put(Hamster("Charlie")) eq false
    cage.take()
    cage.capacity eq 1
  }
  ```

  - `full` ê³¼ `capacity` ëŠ” ë‚´ë¶€ í”„ë¡œí¼í‹° ê°’ì„ ì´ìš©í•´ì„œ getterë¥¼ ì •ì˜í•˜ê³  ìˆë‹¤.

- ë¦¬íŒ©í† ë§

  ```kotlin
  class Cage2(private val maxCapacity: Int) {
    private val hamsters =
      mutableListOf<Hamster>()
    fun capacity(): Int =
      maxCapacity - hamsters.size
    fun isFull(): Boolean =
      hamsters.size == maxCapacity
  }
  ```

  - ìœ„ì—ì„œ `full` ê³¼ `capacity` ë¥¼ í”„ë¡œí¼í‹°ë¥¼ ë©¤ë²„í•¨ìˆ˜ë¡œ ë³€ê²½í•  ìˆ˜ ìˆë‹¤.
  - í”„ë¡œí¼í‹° vs ë©¤ë²„í•¨ìˆ˜??
    - ì½”í‹€ë¦° ìŠ¤íƒ€ì¼ ê°€ì´ë“œì—ì„œëŠ” ê³„ì‚°ë¹„ìš©ì´ ë§ì§€ì•Šê³ , ê°ì²´ìƒíƒœë¥¼ ë³€ê²½í•˜ì§€ ì•ŠëŠ” í•œ ë©¤ë²„í•¨ìˆ˜ë³´ë‹¤ëŠ” **í”„ë¡œí¼í‹°**ë¥¼ ì‚¬ìš©í•  ê²ƒì„ ì¶”ì²œ

## Atom29 : 2ë¶€ ìš”ì•½

### íŒ¨í‚¤ì§€ì™€ í…ŒìŠ¤íŠ¸

### ê°ì²´ëŠ” ëª¨ë“  ê³³ì— ì¡´ì¬í•œë‹¤

### í´ë˜ìŠ¤ ë§Œë“¤ê¸°

### ìƒì„±ì

### ê°€ì‹œì„± ì œí•œí•˜ê¸°

### ì˜ˆì™¸

### ë¦¬ìŠ¤íŠ¸

### íŒŒë¼ë¯¸í„°í™”í•œ íƒ€ì…

### ê°€ë³€ì¸ì ëª©ë¡

### ì§‘í•©

### ë§µ

### í”„ë¡œí¼í‹° ì ‘ê·¼ì

## Atom30 í™•ì¥ í•¨ìˆ˜

- í™•ì¥ í•¨ìˆ˜(extension function) ì •ì˜

  ```kotlin
  fun String.singleQuote() = "'$this'"
  fun String.doubleQuote() = "\"$this\""

  fun main() {
    "Hi".singleQuote() eq "'Hi'"
    "Hi".doubleQuote() eq "\"Hi\""
  }
  ```

  - ê¸°ì¡´ í´ë˜ìŠ¤ì—ì„œ ë©¤ë²„ í•¨ìˆ˜ë¥¼ ì¶”ê°€í•˜ëŠ” ê²ƒê³¼ ê°™ì€ íš¨ê³¼ë¥¼ ë‚´ëŠ” í•¨ìˆ˜ë¥¼ í™•ì¥ í•¨ìˆ˜ë¼ê³  í•œë‹¤. ê·¸ë˜ì„œ ë§ˆì¹˜ ê¸°ì¡´ í´ë˜ìŠ¤ì˜ ë©¤ë²„ í•¨ìˆ˜ì²˜ëŸ¼ í˜¸ì¶œí•´ì„œ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.

  - `fun ìˆ˜ì‹ íƒ€ì….í™•ì¥í•¨ìˆ˜() { .... }`

    - ì •ì˜ì—ì„œ ì íŒ **ìˆ˜ì‹ íƒ€ì…** ì´ë€ : í™•ì¥í•  ëŒ€ìƒ íƒ€ì…ì„ ì˜ë¯¸í•˜ê³ , ìˆ˜ì‹ ê°ì²´ íƒ€ì…(receiver type)ì´ë¼ê³  ë¶€ë¥¸ë‹¤.

- ì„í¬íŠ¸ ë°©ë²•

  ```kotlin
    import atomictest.eq
    import extensionfunctions.doubleQuote // âœ…
    import extensionfunctions.singleQuote // âœ…

    fun main() {
      "Single".singleQuote() eq "'Single'"
      "Double".doubleQuote() eq "\"Double\""
    }
  ```

- í™•ì¥ í•¨ìˆ˜ì—ì„œì˜ this

  ```kotlin
    fun String.strangeQuote() =
      this.singleQuote().singleQuote()

    fun String.tooManyQuotes() =
      doubleQuote().doubleQuote() // âœ…

    fun main() {
      "Hi".strangeQuote() eq "''Hi''"
      "Hi".tooManyQuotes() eq "\"\"Hi\"\""
    }
  ```

  - í´ë˜ìŠ¤ ë‚´ë¶€ì—ì„œ thisë¥¼ ìƒëµê°€ëŠ¥í•œ ê²ƒê³¼ ë§ˆì°¬ê°€ì§€ë¡œ í™•ì¥ í•¨ìˆ˜ì—ì„œë„ ìƒëµ ê°€ëŠ¥

- í™•ì¥ í•¨ìˆ˜ì˜ ì¥ì  : ê°„ë‹¨í•œ ì½”ë“œ ìƒì„±

  ```kotlin
    class Book(val title: String)

    fun Book.categorize(category: String) =
      """title: "$title", category: $category"""

    fun main() {
      Book("Dracula").categorize("Vampire") eq
        """title: "Dracula", category: Vampire"""
    }
  ```

  - í™•ì¥ í•¨ìˆ˜ëŠ” ìˆ˜ì‹  ê°ì²´ íƒ€ì…ì˜ í”„ë¡œí¼í‹°ê°€ publicì¸ ê²½ìš°ì—ë§Œ ì ‘ê·¼ì´ ê°€ëŠ¥í•˜ë‹¤.
  - `class Book(private val title: String)` : error ë°œìƒ (`Cannot access 'title': it is private in 'Book'`)

  - ì •ë§ ê°„ê²°í•˜ë‹ˆ?? : ìŒ...ğŸ¤”

    > í™•ì¥í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ì§€ ì•ŠëŠ” ê°™ì€ ê²°ê³¼ë¥¼ ì–»ì–´ë‚´ëŠ” ì½”ë“œ

    ```kotlin
      class Book(val title: String) {

          fun categorize(category: String) =
              """title: "$title", category: $category"""
      }

      fun main() {
          val book = Book("Dracula")
          book.categorize("Vampire") eq
                  """title: "Dracula", category: Vampire"""
      }
    ```

- í™•ì¥í•¨ìˆ˜ ìœ ë¬´ ë¹„êµ (feat.chatGPT)

  - í™•ì¥í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ì§€ ì•Šì€ ê²ƒ

    ```kotlin
    fun capitalizeFirstLetter(str: String): String {
        if (str.isEmpty()) return str
        return str.substring(0, 1).uppercase() + str.substring(1)
    }

    fun main() {
        val strings = listOf("hello", "world", "kotlin")
        val capitalizedStrings = strings.map { capitalizeFirstLetter(it) }

        println(capitalizedStrings) // [Hello, World, Kotlin]
    }
    ```

  - í™•ì¥í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•œ ê²ƒ

    ```kotlin
    // String íƒ€ì…ì— ëŒ€í•œ í™•ì¥ í•¨ìˆ˜ ì •ì˜
    fun String.capitalizeFirstLetter(): String {
        if (this.isEmpty()) return this
        return this.substring(0, 1).uppercase() + this.substring(1)
    }

    fun main() {
        val strings = listOf("hello", "world", "kotlin")
        val capitalizedStrings = strings.map { it.capitalizeFirstLetter() }

        println(capitalizedStrings) // [Hello, World, Kotlin]
    }
    ```

    - ê°€ë…ì„± í–¥ìƒ: ê¸°ì¡´ í´ë˜ìŠ¤ì˜ ë©”ì„œë“œë¥¼ í˜¸ì¶œí•˜ëŠ” ê²ƒì²˜ëŸ¼ ì½”ë“œê°€ ìì—°ìŠ¤ëŸ½ê³  ì½ê¸° ì‰½ë‹¤.
      - `it.capitalizeFirstLetter()`
    - ìº¡ìŠí™”: í™•ì¥ í•¨ìˆ˜ë¥¼ í†µí•´ íŠ¹ì • í´ë˜ìŠ¤ì— ê´€ë ¨ëœ ë™ì‘ì„ í•´ë‹¹ í´ë˜ìŠ¤ ë‚´ë¶€ë¡œ ìº¡ìŠí™” í•  ìˆ˜ ìˆë‹¤. ì´ëŠ” ì½”ë“œì˜ ì‘ì§‘ë„ë¥¼ ë†’ì´ê³ , ë‹¤ë¥¸ ê³³ì—ì„œ ì¬ì‚¬ìš©í•  ë•Œ ìœ ìš©í•˜ë‹¤.
    - ì½”ë“œ ì¤‘ë³µ ê°ì†Œ: ì—¬ëŸ¬ ê³³ì—ì„œ ë™ì¼í•œ ì‘ì—…ì„ ìˆ˜í–‰í•´ì•¼ í•˜ëŠ” ê²½ìš°, í™•ì¥ í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ë©´ ì½”ë“œ ì¤‘ë³µì„ ì¤„ì¼ ìˆ˜ ìˆë‹¤. í•„ìš”í•  ë•Œë§ˆë‹¤ ë³„ë„ì˜ í•¨ìˆ˜ë¥¼ importí•˜ì—¬ ì‚¬ìš©í•˜ëŠ” ëŒ€ì‹ , í™•ì¥ í•¨ìˆ˜ë¡œ ì •ì˜ëœ ë©”ì„œë“œë¥¼ í˜¸ì¶œí•˜ë©´ ëœë‹¤.
    - ê¸°ì¡´ ì½”ë“œ ìˆ˜ì • ë¶ˆí•„ìš”: í™•ì¥ í•¨ìˆ˜ëŠ” ê¸°ì¡´ í´ë˜ìŠ¤ë‚˜ ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ìˆ˜ì •í•˜ì§€ ì•Šê³ ë„ ìƒˆë¡œìš´ ê¸°ëŠ¥ì„ ì¶”ê°€í•  ìˆ˜ ìˆê²Œ í•œë‹¤. ì´ëŠ” ì™¸ë¶€ ë¼ì´ë¸ŒëŸ¬ë¦¬ë‚˜ ì„œë“œíŒŒí‹° ì½”ë“œë¥¼ ì‚¬ìš©í•  ë•Œ íŠ¹íˆ ìœ ìš©í•  ìˆ˜ ìˆë‹¤.
