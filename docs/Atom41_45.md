# Atomic Kotlin 41 ~ 45

## Atom41 제네릭스 소개

- 제네릭의 정의
  - 타입의 플레이스홀더. 아직 정해지지 않은 타입을 대신해서 보여준다는 의미로 이해
  - 클래스나 함수를 작성할 때 **타입 제약을 느슨하게** 해서 프로그래머에게 표현력을 최대로 제공하고자하는 목적에서 나온 것

```kotlin
  data class Automobile(val brand: String)

  class RigidHolder(private val a: Automobile) {
    fun getValue() = a
  }

  fun main() {
    val holder = RigidHolder(Automobile("BMW"))
    holder.getValue() eq
      "Automobile(brand=BMW)"
  }
```

- RigidHolder 라는 클래스에 항상 인자로 `Automobile` 밖에 받을 수 없다. 다른 다양한 타입을 받기 위해선 각각 따로 만들어줘야한다. → **재사용성이 좋지 않다.**

- 이를 해결하기 위해서 제네릭 사용(아래 코드)

```kotlin
  class GenericHolder<T>(               // [1]
    private val value: T
  ) {
    fun getValue(): T = value
  }

  fun main() {
    val h1 = GenericHolder(Automobile("Ford"))
    val a: Automobile = h1.getValue()   // [2]
    a eq "Automobile(brand=Ford)"

    val h2 = GenericHolder(1)
    val i: Int = h2.getValue()          // [3]
    i eq 1

    val h3 = GenericHolder("Chartreuse")
    val s: String = h3.getValue()       // [4]
    s eq "Chartreuse"
  }
```

- `class GenericHolder<T>` 클래스명 뒤에 `<T>` 를 통해서 제네릭을 정의하고 해당 타입이 어디에 어떻게 사용될지 설정한다.
  - 위 클래스에서는 인자로 받는 타입과 getValue가 리턴하는 타입이 같다.
- `<T>` 에는 해당 클래스가 실제로 사용되기 전까지는 어떤 타입이 들어올지 모른다. [2]/[3]/[4]에서 처럼 실제로 클래스에 특정 타입의 인자가 들어오게 되면 해당 타입이 설정된다.

<br />

- 유니버설 타입
  - 모든 타입의 부모 타입을 일컫는 용어
  - 코틀린에서는 `Any` : 모든 타입을 허용한다는 의미
  - 만약 여러 타입의 값을 넘겨야하는 경우, 공통점이 없다면 Any 타입을 제네릭 대신 선언이 가능해보인다.
    - ex. `class GenericHolder<Any>`

<br />

```kotlin
  class AnyHolder(private val value: Any) {
    fun getValue(): Any = value
  }

  class Dog {
    fun bark() = "Ruff!"
  }

  fun main() {
    val holder = AnyHolder(Dog())
    val any = holder.getValue()
    // Doesn't compile:
    // any.bark()

    val genericHolder = GenericHolder(Dog())
    val dog = genericHolder.getValue()
    dog.bark() eq "Ruff!"
  }
```

- `AnyHolder`의 경우 인자로 받은 값의 타입이 Any 타입으로, getValue에서 리턴하는 타입 역시 Any 타입으로 정의되어 있는 것.

  - 그렇기 때문에 `val any = holder.getValue()` 의 any는 Any 타입이기 때문에 ~~Any 타입에는 bark()라는 멤버함수가 없기 때문에 컴파일 할 수 없게 된다.~~

    → **설명 수정** : Any 타입으로 선언된 변수가 실제로 어떤 타입인지 알 수 없기 때문에 안전하게 접근이 불가능하여 컴파일 에러가 발생하게 된다.

  - 아래와 같은 에러가 발생!
    ![atom41_any](/screenshots/atom41_any.png)

- 위 예제를 통한 제네릭과 Any타입을 정리

  - 제네릭 타입 : 실행시점에 구체적인 타입으로 대체되며 그 타입에 맞게 동작
  - Any 타입 : 모든 타입의 슈퍼타입으로, 어떤 값이든 참조할 수 있지만, 그 값의 구체적인 타입을 알 수 없기 때문에 해당 타입의 멤버/멤버함수에 직접 접근할 수 없다. 단, **타입 캐스팅이나 is 연산자를 통하면 접근이 가능**

    ```kotlin
    fun main() {
      val holder = AnyHolder(Dog())
      val any = holder.getValue()

      // 1) is 연산자
      if (any is Dog)
          any.bark()

      // 2) 타입캐스팅
      (any as? Dog)?.bark()
    }
    ```

    > 이런 식으로 변경하면 접근이 가능!

    > is 연산자 : `any is Dog` any가 Dog 타입인지를 확인하는 방식으로 맞다면 그 이후 코드를 실행

    > as / as? : 강제 타입 캐스팅 / 안전한 타입 캐스팅
    >
    > > as : 캐스팅 중 캐스팅이 불가능하면 에러(`ClassCastException`) 발생
    > > as? : 캐스팅 중 캐스팅이 불가능하면 null 반환

```kotlin
  fun <T> identity(arg: T): T = arg

  fun main() {
    identity("Yellow") eq "Yellow"
    identity(1) eq 1
    val d: Dog = identity(Dog())
    d.bark() eq "Ruff!"
  }
```

- 제네릭 함수의 경우 제네릭 명세(ts에서는 타입 변수라고 부름)를 함수 앞에 정의한다.

```kotlin
  fun <T> List<T>.first(): T {
    if (isEmpty())
      throw NoSuchElementException("Empty List")
    return this[0]
  }

  fun <T> List<T>.firstOrNull(): T? =
    if (isEmpty()) null else this[0]

  fun main() {
    listOf(1, 2, 3).first() eq 1

    val i: Int? =                     // [1]
      listOf(1, 2, 3).firstOrNull()
    i eq 1

    val s: String? =                  // [2]
      listOf<String>().firstOrNull()
    s eq null
  }
```

- 제네릭 확장함수의 경우에도 확장 함수의 수신객체 앞에 제네릭 명세를 붙인다.

- 책에서 시험삼아 식별자 ? 를 제거해보라고 해서 제거해봄! 😈 예상했듯이 `firstOrNull()`의 반환 타입과 타입이 맞지 않기때문에 타입오류가 노출된다.
  ![atom41_generic_extension](/screenshots/atom41_generic_extension.png)

## Atom42 확장 프로퍼티

> 확장함수 처럼 프로퍼티를 확장하는 개념인데... 사실 정확하게 설명하는바가 와닿지 않음. 그래서

```kotlin
val String.indices: IntRange
  get() = 0 until length

fun main() {
  "abc".indices eq 0..2
}
```

```kotlin
val <T> List<T>.firstOrNull: T?
  get() = if (isEmpty()) null else this[0]

fun main() {
  listOf(1, 2, 3).firstOrNull eq 1
  listOf<String>().firstOrNull eq null
}
```

```kotlin
val List<*>.indices: IntRange
  get() = 0 until size

fun main() {
  listOf(1).indices eq 0..0
  listOf('a', 'b', 'c', 'd').indices eq 0..3
  emptyList<Int>().indices eq IntRange.EMPTY
}
```

```kotlin
fun main() {
  val list: List<*> = listOf(1, 2)
  val any: Any? = list[0]
  any eq 1
}
```

## Atom43 break와 continue

> Atom43은 코틀린만의 특성을 설명하는 것은 아니고, 코드의 흐름을 읽어가는 과정에 대한 이야기

- 흐름

  - goto : 코드 사이를 직접 점프할 수 있게 해주는 키워드
    - 초기 프로그래밍 방식에서 많이 사용되었고 초기 고수준의 언어(포트란, C, C++)에서 많이 채택함
    - 단점 : 사용 경험이 많아짐에 따라서 조건없는 점프는 코드의 유지보수와 가독성을 떨어뜨린다는 사실을 발견, 이후 고수준 언어에서는 이러한 무조건적인 코드 점프 방식을 채택하지 않음
  - break & continue
    - goto의 연장선상으로 볼 수 있는 break와 continue는 제한적인 점프를 제공하는 키워드
    - 단 루프(for,do-while 등)에서만 위의 키워드를 사용할 수 있음

- 정의

  - continue : 루프의 시작 위치로 점프, 즉 continue 키워드 밑의 코드는 실행하지 않고 다시 처음으로 돌아옴
  - break : 루프의 끝으로 이동, 즉, break 키워드는 루프를 종료하게됨.

    → 실제 코틀린에서는 위의 두 키워드를 사용할 일이 드물다고 한다. 코틀린에서는 이보다는 더 좋은 옵션을 제공하는 방법에 대해서 앞으로 배우게 된다고 함. 👍🏻👍🏻

```kotlin
fun main() {
  val nums = mutableListOf(0)
  for (i in 4 until 100 step 4) {    // [1]
    if (i == 8) continue             // [2]
    if (i == 40) break               // [3]
    nums.add(i)
  }                                  // [4]
  nums eq "[0, 4, 12, 16, 20, 24, 28, 32, 36]"
}
```

- 4 ~ 100까지 4칸씩 점프하면서 루프를 돈다.
- 8은 건너뛰고, 40에서 루프를 종료한다. 그래서 `4 <= X < 40` 범위에서 8이 아닌 4의 배수의 리스트가 담긴다.
- 두개의 if조건은 겹치지 않기때문에 서로 바뀌어도 결과는 변하지 않는다.

```kotlin
fun main() {
  val nums = mutableListOf(0)
  var i = 0
  while (i < 100) {
    i += 4
    if (i == 8) continue
    if (i == 40) break
    nums.add(i)
  }
  nums eq "[0, 4, 12, 16, 20, 24, 28, 32, 36]"
}
```

- 첫번째 코드블락에서의 for문을 while문으로 대체한 것이다.

```kotlin
fun main() {
  val nums = mutableListOf(0)
  var i = 0
  do {
    i += 4
    if (i == 8) continue
    if (i == 40) break
    nums.add(i)
  } while (i < 100)
  nums eq "[0, 4, 12, 16, 20, 24, 28, 32, 36]"
}
```

- 이 코드 역시 첫번째 코드 블락을 `do-while` 로 변경한 것

  - 개인적으로 C 배울 때 do-while은 한두번정도 사용한 적이 있는듯. 보통 while,for문이 이해하기가 편했음

  - do-while
    - for, while은 모든 루프를 시작할 때 조건을 먼저 확인하고 루프를 실행함
    - do-while은 먼저 실행하고 루프를 실행할지에 대한 조건을 확인함. 그래서 무조건 처음을 실행해야하는 경우에는 do-while로 구현하는게 편할수도 있음 🥲

```kotlin
fun main() {
  val strings = mutableListOf<String>()
  outer@ for (c in 'a'..'e') {
    for (i in 1..9) {
      if (i == 5) continue@outer
      if ("$c$i" == "c3") break@outer
      strings.add("$c$i")
    }
  }
  strings eq listOf("a1", "a2", "a3", "a4",
    "b1", "b2", "b3", "b4", "c1", "c2")
}
```

- 레이블

  - 특정 블럭에 `레이블@` 처럼 일종의 라벨링을 할 수 있고 그 블럭으로 이동하여 작업을 진행할 수 있음
  - break와 continue는 자신이 속한 루프 밖으로는 점프할 수 없지만, 레이블은 루프 밖으로 이동이 가능

- `outer@` 로 첫번째 for문 블럭으로 라벨링을 하였음.
  - `if (i == 5) continue@outer` : i가 5일때마다 이중for문을 처음으로 돌아가서 시작하게 됨
  - `if ("$c$i" == "c3") break@outer` : `outer@` 레이블 끝으로 가서 끝으로 이동하게 됨. 즉 이중for문이 종료됨
    → Q. `if ("$c$i" == "c3") break;` 코드가 이렇게 바뀌면 어떻게 될까??
    - break로 인해 안쪽 for문만 종료되고 바깥쪽 for문으로 이동하여 for문이 진행된다. a ~ e까지 모두 돌게 됨.
    - 결과 `[a1, a2, a3, a4, b1, b2, b3, b4, c1, c2, d1, d2, d3, d4, e1, e2, e3, e4]`

```kotlin
fun main() {
  val strings = mutableListOf<String>()
  var c = 'a' - 1
  outer@ while (c < 'f') {
    c += 1
    var i = 0
    do {
      i++
      if (i == 5) continue@outer
      if ("$c$i" == "c3") break@outer
      strings.add("$c$i")
    } while (i < 10)
  }
  strings eq listOf("a1", "a2", "a3", "a4",
    "b1", "b2", "b3", "b4", "c1", "c2")
}
```

- 위 코드를 do-while로 변경한 코드

- `continue@outer`, `break@outer` 위의 코드와 동일하게 동작함

- [참고] 코틀린은 Char타입이 존재하여 내부적으로 유니코드 값을 가지고 있어서 Char 타입의 산술 연산이 가능하다.

  - `var c = 'a' - 1`, `c += 1` 이렇게 연산을 통해서 알파벳을 변경할 수 있음

```kotlin
fun main() {
  val strings = mutableListOf<String>()
  for (c in 'a'..'c') {
    for (i in 1..4) {
      val value = "$c$i"
      if (value < "c3") {     // [1]
        strings.add(value)
      }
    }
  }
  strings eq listOf("a1", "a2", "a3", "a4",
    "b1", "b2", "b3", "b4", "c1", "c2")
}
```

- 위 코드는 레이블을 사용하지 않고도 같은 결과를 반환하는 함수로 리팩토링한 것.

  - 각각 이중for문에서 순회해야할 범위를 변경
  - if문을 통해 리스트에 추가해야할 요소 조건 분기

- [지극히 개인적인 의견] 약간 억지스러운 리팩토링

  - 예시를 위한 예시 느낌
  - 순회 범위를 변경 → 순회해야할 범위만 순회하는건 너무도 당연한것 아닐까??
  - 보통 break와 continue 를 사용하는 경우는 어쩔수 없이 모든 순회를 돌아야하는데 특정 경우에서만 다른 로직을 처리하고 싶은 경우에 사용하는데, 과연 위 예시가 과연 이런 의도와 의문.

- [참고] 코틀린의 문자열 비교

  - 파이썬과 타스에서는 정상동작하는데, 강타입 언어인 코틀린에서도 정상 작동하는지 의문
  - `value < "c3"`의 비교 방식

    - 두 문자열을 **사전식(lexicographical)** 으로 비교한다. 문자열 비교는 **각 문자의 유니코드 값을 기준**으로 수행되며, 문자열의 길이는 우선 고려되지 않는다.

    - 예시
      - `"apple" < "banana"`: true
      - `"apple" > "applet"` : false
      - `"apple" < "app"` : false
      - `"app" < "apple"` : true

    <br />

## Atom44

## Atom45
